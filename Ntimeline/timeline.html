<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>実施列車運転計画表 (最終調整版 V23)</title>
    <style>
        /* ----------------------------------------------------------------
        * 1. ベースCSS 
        * ---------------------------------------------------------------- */
        body {
            font-family: 'ＭＳ ゴシック', 'MS Gothic', 'Osaka-Mono', monospace;
            background-color: #000080; 
            color: #c0c0c0;
            margin: 0;
            padding: 15px;
            font-size: 14px;
            min-width: 320px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #ffff00;
            text-align: center;
            border-bottom: 2px solid #c0c0c0;
            padding-bottom: 5px;
            margin-bottom: 15px;
            flex-shrink: 0;
            position: relative;
        }
        
        #output-datetime {
            position: absolute;
            bottom: 5px;
            right: 0;
            font-size: 0.75em;
            color: #888888;
        }

        /* 制御パネル */
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 15px;
            margin-bottom: 15px;
            background-color: #000000;
            padding: 10px;
            border: 1px solid #c0c0c0;
            justify-content: flex-start;
            flex-shrink: 0;
        }

        #controls label, #controls input, #controls select, #controls button {
            color: #c0c0c0;
            background-color: #000000;
            border: 1px solid #c0c0c0;
            padding: 3px 5px;
            font-family: inherit;
        }
        
        #controls button:hover {
            background-color: #333333;
            cursor: pointer;
        }
        
        #controls select option {
            background-color: #000080; 
        }

        #fullscreen-button {
            background-color: #555555;
            border: 1px solid #c0c0c0;
            color: #ffffff;
            font-weight: bold;
            padding: 3px 10px;
        }
        #fullscreen-button:hover {
             background-color: #777777;
        }
        
        /* ズームコントローラーのスタイル */
        #zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            padding-left: 20px;
            border-left: 1px solid #444444;
        }
        #zoom-range {
            width: 150px;
        }
        #zoom-value {
            font-size: 0.8em;
        }

        /* ----------------------------------------------------------------
        * 2. タイムライン表示エリア 
        * ---------------------------------------------------------------- */
        #schedule-container {
            overflow: auto; 
            flex-grow: 1;
            border: 2px solid #c0c0c0;
            background-color: #000000;
        }

        #schedule-table {
            display: grid;
            grid-template-columns: var(--op-label-width, 100px) repeat(1440, 1fr); 
            min-width: var(--timeline-min-width, 4000px); 
            border-collapse: collapse;
        }

        /* 時刻ヘッダー */
        .time-header-cell {
            grid-column: span 60; 
            text-align: left;
            padding: 5px 0 5px 5px;
            border-right: 1px solid #333333;
            box-sizing: border-box;
            font-size: 0.9em;
            background-color: #111111;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* 運用ラベル - 2行表示 */
        .operation-label {
            grid-column: 1 / 2;
            padding: 5px;
            border-bottom: 1px dotted #333333;
            background-color: #222222;
            font-weight: bold;
            position: sticky;
            left: 0;
            z-index: 5;
            white-space: nowrap;
            font-size: 1.0em;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            line-height: 1.2;
            cursor: pointer; 
        }
        
        .operation-label:hover {
            background-color: #444444;
        }
        
        /* 運行データがない運用は色を薄くする */
        .operation-label.no-runs {
            color: #666666;
            background-color: #1a1a1a;
        }

        .operation-label span.division {
            font-size: 0.8em;
            color: #888888;
            font-weight: normal;
        }
        .operation-label span.number {
            font-weight: bold;
        }

        .train-run-container {
            grid-column: 2 / 1442; 
            position: relative;
            height: 40px;
            border-bottom: 1px dotted #333333;
        }

        /* 運行ブロックのCSS */
        .train-block {
            position: absolute;
            height: 30px;
            top: 5px;
            border: 1px solid #c0c0c0;
            cursor: pointer;
            font-size: 0.75em; 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 0 5px;
            white-space: nowrap;
            transition: all 0.1s;
            box-sizing: border-box;
        }

        .highlight {
            border: 3px solid #ffff00 !important;
            box-shadow: 0 0 10px #ffff00;
            background-color: #4b0082 !important;
        }

        /* ステータスごとの色の定義 */
        .status-計画中 { background-color: #0000ff; color: #ffffff; } 
        .status-実施済み { background-color: #008000; color: #ffffff; }
        .status-実施中 { background-color: #ff0000; color: #ffffff; } 
        .status-取り下げ { background-color: #808080; color: #000000; } 

        /* ----------------------------------------------------------------
        * 3. 詳細モーダル 
        * ---------------------------------------------------------------- */
        #modal-overlay {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 50;
            overflow-y: auto;
        }
        
        #detail-modal {
            background-color: #c0c0c0;
            color: #000000;
            border: 3px outset #ffffff; 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 900px;
            box-shadow: 8px 8px 0 #000000;
            font-family: inherit;
        }
        
        #close-modal {
            background-color: red;
            color: white;
            border: none;
            cursor: pointer;
            padding: 3px 8px;
            font-weight: bold;
            position: absolute;
            right: 5px;
            top: 5px;
        }

        .modal-content {
            padding: 15px;
            line-height: 1.5;
            display: flex;
            flex-direction: row; 
            gap: 20px;
        }
        
        .modal-info, .modal-timetable {
            flex: 1; 
            min-width: 300px;
        }

        .modal-timetable {
            overflow-y: auto;
            max-height: 400px; 
            border: 1px solid #808080;
        }
        
        /* 運用全体表示のテーブル用スタイル */
        .modal-op-runs-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-family: inherit;
        }
        .modal-op-runs-table th, .modal-op-runs-table td {
            border: 1px solid #808080;
            padding: 5px;
            text-align: left;
            font-size: 0.9em;
            background-color: #c0c0c0;
            color: #000000;
        }
        .modal-op-runs-table th {
            background-color: #000080;
            color: #ffffff;
        }
        
        .modal-op-runs-table tr:hover td {
             background-color: #e0e0e0;
        }

        .modal-header {
            background-color: #000080; 
            color: #ffffff;
            padding: 5px;
            font-weight: bold;
            position: relative;
        }

        .modal-info dt {
            font-weight: bold;
            color: #000080;
            margin-top: 5px;
        }
        
        .modal-timetable th, .modal-timetable td {
            border: 1px solid #808080;
            padding: 3px;
            text-align: left;
            background-color: #c0c0c0;
            color: #000000;
        }
        
        /* V22: 区間ヘッダーは非表示にするため不要 (しかし、念のためCSSは残す) */
        .modal-timetable .segment-header {
             /* display: none; */ /* JS側でTRを挿入しないようにするが、スタイルは残す */
             background-color: #000080; 
             color: #ffffff; 
             font-weight: bold; 
             border-top: 3px solid #ffffff;
        }
        
        /* V23: 時刻列幅固定と駅名/番線幅調整 */
        .modal-timetable table {
            table-layout: fixed;
            width: 100%; 
        }
        .modal-timetable table col.station-col {
            width: 30%; /* 駅名 */
        }
        .modal-timetable table col.time-col {
            width: 27.5%; /* 着時刻/発時刻 */
        }
        .modal-timetable table col.track-col {
             width: 15%; /* 番線（狭く） */
        }
        .modal-timetable table th:nth-child(2),
        .modal-timetable table td:nth-child(2),
        .modal-timetable table th:nth-child(3),
        .modal-timetable table td:nth-child(3) {
            text-align: center; /* 時刻を中央寄せ */
        }

        /* 運用詳細情報 (V18/V19修正) */
        #all-runs-container dt {
             font-weight: bold;
             color: #000080;
             margin-right: 5px; 
             display: inline;
        }
        #all-runs-container dd {
             margin-left: 0;
             margin-right: 15px;
             display: inline-block;
        }
        .op-details-line {
            line-height: 1.8;
            border-bottom: 1px solid #808080;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .op-details-line:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }


        /* 縦画面対応 */
        @media (max-width: 800px) {
            .modal-content { flex-direction: column; }
            .modal-timetable { min-width: unset; max-height: 300px; }
            #detail-modal { width: 95%; top: 20px; transform: translate(-50%, 0); position: absolute; }
            #modal-overlay { overflow-y: auto; }
        }

    </style>
</head>
<body>

    <h1>実施列車運転計画表 V2.3
        <span id="output-datetime"></span>
    </h1> 

    <div id="controls">
        <label for="date-selector">表示日付:</label>
        <input type="date" id="date-selector">
        
        <label for="division-selector">区所絞り込み:</label>
        <select id="division-selector">
            <option value="">全ての区所</option>
            </select>
        
        <label for="search-train-number">列車番号検索:</label>
        <input type="text" id="search-train-number" placeholder="例: 8764">
        <button id="search-button">検 索</button>
        <button id="clear-search">解除</button>
        
        <button id="fullscreen-button">全画面表示</button>

        <div id="zoom-controls">
            <label>横軸ズーム:</label>
            <input type="range" id="zoom-range" min="1000" max="10000" step="500" value="4000">
            <span id="zoom-value">4000px</span>
        </div>
    </div>

    <div id="schedule-container">
        <div id="schedule-table">
            </div>
    </div>

    <div id="status-menu" style="display: none;"></div>
    
    <div id="modal-overlay">
        <div id="detail-modal">
            <div class="modal-header">
                <span id="modal-title">列車運行詳細情報</span>
                <button id="close-modal">X</button>
            </div>
            <div id="modal-content" class="modal-content">
                <div class="modal-info">
                    <dl id="block-details">
                        </dl>
                </div>
                <div class="modal-timetable">
                    <div id="timetable-details">
                        </div>
                </div>
            </div>
            <div id="all-runs-container" style="padding: 15px; display: none;">
                <h3 id="operation-runs-title" style="color: #000080;"></h3>
                <div id="all-runs-list"></div>
            </div>
        </div>
    </div>


    <script>
        // ----------------------------------------------------------------
        // 1. 定数とDOM要素
        // ----------------------------------------------------------------
        const TIMETABLES_URL = '../T-time/timetables.json'; 
        const DATA_URL = '../unnyou/data.json'; 
        const MIN_IN_DAY = 1440; 
        
        const scheduleTable = document.getElementById('schedule-table');
        const dateSelector = document.getElementById('date-selector');
        const divisionSelector = document.getElementById('division-selector');
        const searchInput = document.getElementById('search-train-number');
        const searchButton = document.getElementById('search-button');
        const clearSearchButton = document.getElementById('clear-search');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const allRunsContainer = document.getElementById('all-runs-container');
        const operationRunsTitle = document.getElementById('operation-runs-title');
        const scheduleContainer = document.getElementById('schedule-container');
        const outputDatetimeSpan = document.getElementById('output-datetime');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const zoomRange = document.getElementById('zoom-range'); 
        const zoomValueSpan = document.getElementById('zoom-value'); 

        let globalTimetables = [];
        let globalData = []; // 元の運用JSONを保持
        let currentScheduleData = []; // タイムライン描画用の統合/フィルタ済みデータを保持
        let selectedDate = null;
        let today = new Date(); 
        
        // 時刻表データを列車番号と施行日でマップ化し、ルックアップを高速化
        let timetablesMap = new Map();

        const ALWAYS_VISIBLE_DATES = [
            '2025/03/15',
            '2026/03/14'
        ];
        
        // 時刻データと見なされる特殊記号 (V21/V22でそのまま表示)
        const TIME_MARKERS = ['||', '=', '…'];


        // ----------------------------------------------------------------
        // 2. ユーティリティ関数とデータ処理
        // ----------------------------------------------------------------

        function timeToMinutes(timeStr) {
            // Null, 空白、またはマーカー文字の場合はnullを返す
            if (!timeStr || timeStr.trim() === "" || TIME_MARKERS.includes(timeStr.trim())) return null;
            const parts = timeStr.split(':');
            if (parts.length < 2) return null;
            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);
            return hours * 60 + minutes;
        }
        
        function formatMinutesToTime(minutes) {
             if (minutes === null) return ''; 
             const h = Math.floor(minutes / 60);
             const m = minutes % 60;
             return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        }

        function formatDate(date) {
            if (!date) return null;
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}/${m}/${d}`;
        }
        
        function parseJsonDate(dateStr) {
            if (!dateStr) return null;
            const parts = dateStr.split('/');
            return new Date(parts[0], parts[1] - 1, parts[2]);
        }
        
        function getAutoStatus(startDateStr, currentDate) {
            if (!startDateStr || !currentDate) return "計画中";
            
            const startDate = parseJsonDate(startDateStr);
            const currentDayStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate()).getTime();
            const startDayStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate()).getTime();
            
            if (startDayStart < currentDayStart) {
                return "実施済み";
            } else if (startDayStart > currentDayStart) {
                return "計画中";
            } else {
                return "実施中";
            }
        }

        async function fetchJson(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP Error: ${response.status} (${url})`);
            return await response.json();
        }
        
        /**
         * timetables.json を 列車番号_施行日 でマップ化する
         */
        function preprocessTimetables(timetables) {
            const map = new Map();
            timetables.forEach(t => {
                const dateKey = t.startDate || 'NULL';
                const key = `${t.trainNumber}_${dateKey}`;
                
                if (!map.has(key)) {
                    map.set(key, []);
                }
                map.get(key).push(t);
            });
            return map;
        }
        
        /**
         * 同じ列車番号・施行日の時刻表エントリを連続性に基づいて完全に結合する (V22ロジック維持)
         */
        function getIntegratedTimetable(trainNumber, startDate, allTimetables) {
            
            const trim = (s) => s ? s.trim() : '';
            const matchingTimetables = allTimetables; 

            if (matchingTimetables.length === 0) return null;
            
            // 1. 始点を見つける
            let currentRun = null;
            let earliestTime = 3000; 
            
            matchingTimetables.forEach(t => {
                // 最初の駅の着/発時刻
                const firstStopDep = t.stops.find(s => timeToMinutes(s.departure) !== null);
                const firstStopArr = t.stops.find(s => timeToMinutes(s.arrival) !== null);
                
                let time = 3000;
                if (firstStopDep) time = timeToMinutes(firstStopDep.departure);
                else if (firstStopArr) time = timeToMinutes(firstStopArr.arrival);
                
                if (time !== 3000 && time < earliestTime) {
                    earliestTime = time;
                    currentRun = t;
                }
            });

            if (!currentRun) return null; 

            const usedTimetables = new Set();
            let combinedRuns = [currentRun];
            usedTimetables.add(currentRun);
            
            const maxSegments = matchingTimetables.length;

            // 2. 前方向 (終点方向) への連続する時刻表を探して結合
            let attempts = 0;
            while (combinedRuns.length < maxSegments && attempts < maxSegments * 2) {
                const lastRun = combinedRuns[combinedRuns.length - 1];
                const nextOrigin = trim(lastRun.destination);
                let nextRun = null;
                
                for (const t of matchingTimetables) {
                    if (!usedTimetables.has(t) && trim(t.origin) === nextOrigin) {
                        nextRun = t;
                        break;
                    }
                }

                if (nextRun) {
                    usedTimetables.add(nextRun);
                    combinedRuns.push(nextRun);
                } else {
                    break; 
                }
                attempts++;
            }
            
            // 3. 後ろ方向 (始点方向) への連続する時刻表を探して結合
            attempts = 0;
            while (combinedRuns.length < maxSegments && attempts < maxSegments * 2) {
                const firstRun = combinedRuns[0];
                const previousDestination = trim(firstRun.origin);
                let previousRun = null;
                
                for (const t of matchingTimetables) {
                    if (!usedTimetables.has(t) && trim(t.destination) === previousDestination) {
                        previousRun = t;
                        break;
                    }
                }
                
                if (previousRun) {
                    usedTimetables.add(previousRun);
                    combinedRuns.unshift(previousRun); // 配列の先頭に追加
                } else {
                    break; 
                }
                attempts++;
            }
            
            // 4. 未使用のセグメントが残っている場合の強制的な追加
            if (combinedRuns.length !== matchingTimetables.length) {
                const unUsed = matchingTimetables.filter(t => !usedTimetables.has(t));
                if (unUsed.length > 0) {
                    const allSegments = [...combinedRuns, ...unUsed].sort((a, b) => {
                        const getFirstTime = (segment) => {
                            const stopDep = segment.stops.find(s => timeToMinutes(s.departure) !== null);
                            if (stopDep) return timeToMinutes(stopDep.departure);
                            const stopArr = segment.stops.find(s => timeToMinutes(s.arrival) !== null);
                            if (stopArr) return timeToMinutes(stopArr.arrival);
                            return 3000; 
                        };
                        return getFirstTime(a) - getFirstTime(b);
                    });
                    combinedRuns = allSegments;
                }
            }


            if (combinedRuns.length === 0) return null;

            const finalFirstRun = combinedRuns[0];
            const finalLastRun = combinedRuns[combinedRuns.length - 1];
            
            // 運行時間計算 (タイムライン表示用)
            let startTime = null;
            const startStop = finalFirstRun.stops.find(s => timeToMinutes(s.departure) !== null);
            if (startStop) startTime = timeToMinutes(startStop.departure);
            
            let endTime = null;
            const endStop = [...finalLastRun.stops].reverse().find(s => timeToMinutes(s.arrival) !== null);
            if (endStop) endTime = timeToMinutes(endStop.arrival);
            
            if (startTime === null || endTime === null) {
                 return null;
            }

            return {
                trainNumber: trainNumber,
                type: finalFirstRun.type,
                startDate: startDate, 
                origin: trim(finalFirstRun.origin), 
                destination: trim(finalLastRun.destination), 
                startTime: startTime,
                endTime: endTime,
                status: null,
                segments: combinedRuns, 
            };
        }


        /**
         * 日付と区所によるフィルタリングを行い、運用データを作成
         */
        function createScheduleData(data, currentDate, divisionFilter) {
            const scheduleData = new Map();
            const divisions = new Set();
            
            data.forEach(op => divisions.add(op.division));
            updateDivisionSelector(divisions);
            
            const formattedCurrentDate = currentDate ? formatDate(currentDate) : null;
            const isDateUnspecified = !dateSelector.value; 
            
            data.forEach(operation => {
                if (divisionFilter && operation.division !== divisionFilter) return;

                const fullOpLabel = `${operation.operation_number} (${operation.division})`;
                const integratedRunsForOp = [];
                const processedRunKeys = new Set(); 

                // 運用JSONの train_runs を 列車番号 でグループ化
                const runsByTrainNumber = new Map();
                operation.train_runs.forEach(run => {
                    if (!runsByTrainNumber.has(run.train_number)) {
                        runsByTrainNumber.set(run.train_number, []);
                    }
                    runsByTrainNumber.get(run.train_number).push(run);
                });

                let foundMatchingRun = false; 

                runsByTrainNumber.forEach((opRuns, trainNumber) => {
                    const firstOpRun = opRuns[0];
                    const lastOpRun = opRuns[opRuns.length - 1];
                    
                    const getRouteStations = (routeStr) => {
                        const parts = routeStr.split(/〜|~/); 
                        return { 
                            start: parts[0] ? parts[0].trim() : null, 
                            end: parts[parts.length - 1] ? parts[parts.length - 1].trim() : null
                        };
                    };
                    
                    const opRouteStart = getRouteStations(firstOpRun.route).start;
                    const opRouteEnd = getRouteStations(lastOpRun.route).end;


                    // 時刻表マップから、この列車番号に関わる全ての施行日を抽出
                    const relevantTimetableEntries = Array.from(timetablesMap.entries())
                        .filter(([key, _]) => key.startsWith(`${trainNumber}_`));
                    
                    // 時刻表エントリを施行日ごとにグループ化し、統合を試みる
                    relevantTimetableEntries.forEach(([key, timeTableGroup]) => {
                        const startDate = key.split('_')[1] === 'NULL' ? null : key.split('_')[1];
                        
                        // 既に統合処理済みの組み合わせかチェック
                        const uniqueRunKey = `${trainNumber}_${startDate}`;
                        if (processedRunKeys.has(uniqueRunKey)) return;

                        // 1. 時刻表統合
                        const integratedTimetable = getIntegratedTimetable(trainNumber, startDate, timeTableGroup);
                        
                        if (!integratedTimetable) return; 
                        
                        // 2. 区間の一致チェック (厳格化)
                        if (opRouteStart !== integratedTimetable.origin || opRouteEnd !== integratedTimetable.destination) {
                             return; 
                        }
                        
                        // 3. 日付フィルタチェック
                        const formattedStartDate = startDate ? formatDate(parseJsonDate(startDate)) : null;

                        let shouldDisplay = false;
                        if (isDateUnspecified) {
                            shouldDisplay = true; // 日付未指定時は、時刻表と区間が一致した全ての運行を表示
                        } else {
                            // 日付指定時は、JSONのstartDateが未設定、ALWAYS_VISIBLE、または選択日と一致する場合に表示
                            const isNoDate = !startDate;
                            const isSpecificDate = ALWAYS_VISIBLE_DATES.includes(formattedStartDate);
                            const isSelectedDate = (formattedStartDate === formattedCurrentDate);
                            shouldDisplay = isNoDate || isSpecificDate || isSelectedDate;
                        }

                        if (!shouldDisplay) return;

                        // 4. データ統合
                        let status = firstOpRun.status || (isDateUnspecified ? "計画中" : getAutoStatus(startDate, currentDate));
                        
                        const runData = {
                            trainNumber: trainNumber,
                            type: integratedTimetable.type,
                            route: opRuns.map(r => r.route).join(' → '), 
                            startStation: integratedTimetable.origin,
                            endStation: integratedTimetable.destination,
                            startTime: integratedTimetable.startTime, 
                            endTime: integratedTimetable.endTime,     
                            status: status, 
                            operationId: operation.id, 
                            operationNumber: operation.operation_number,
                            division: operation.division,
                            runIndex: firstOpRun.runIndex, 
                            startDate: startDate,
                            timetable: integratedTimetable
                        };

                        integratedRunsForOp.push(runData);
                        processedRunKeys.add(uniqueRunKey); 
                        foundMatchingRun = true; 
                    });
                });
                
                // 運行を時間順にソート
                integratedRunsForOp.sort((a, b) => a.startTime - b.startTime);

                if (isDateUnspecified) {
                    // 運用ラベルは、運行データが見つからなくても常に作成する (全運用表示)
                    if (!scheduleData.has(fullOpLabel)) {
                        scheduleData.set(fullOpLabel, {
                            operation_number: operation.operation_number,
                            division: operation.division,
                            vehicles: operation.vehicles,
                            runs: []
                        });
                    }
                    scheduleData.get(fullOpLabel).runs.push(...integratedRunsForOp);
                    scheduleData.get(fullOpLabel).hasRuns = foundMatchingRun;
                } else if (integratedRunsForOp.length > 0) {
                    // 日付指定時は、運行が見つかった運用のみ表示する
                    if (!scheduleData.has(fullOpLabel)) {
                        scheduleData.set(fullOpLabel, {
                            operation_number: operation.operation_number,
                            division: operation.division,
                            vehicles: operation.vehicles,
                            runs: []
                        });
                    }
                    scheduleData.get(fullOpLabel).runs.push(...integratedRunsForOp);
                    scheduleData.get(fullOpLabel).hasRuns = true;
                }
            });

            return Array.from(scheduleData.values());
        }


        /**
         * 列車ブロッククリック時の詳細モーダル表示
         */
        function openDetailModal(trainNumber, operationNumber, division) {
            const operation = currentScheduleData.find(op => op.operation_number === operationNumber && op.division === division);
            const integratedRun = operation?.runs.find(r => r.trainNumber === trainNumber);

            if (!integratedRun || !integratedRun.timetable) {
                alert('ERROR: 詳細データが見つかりません。');
                return;
            }
            
            const displayTimetable = integratedRun.timetable; 
            
            // モーダルを列車詳細モードに設定
            modalTitle.textContent = `列車運行詳細情報: ${trainNumber}`;
            modalContent.style.display = 'flex';
            allRunsContainer.style.display = 'none';

            // V23: 項目名修正
            let detailHtml = `
                <dt>運用番号 (区所)</dt><dd>${operation.operation_number} (${operation.division})</dd>
                <dt>形式</dt><dd>${operation.vehicles}</dd>
                <dt>列車番号</dt><dd>${trainNumber}</dd>
                <dt>列車種別</dt><dd>${displayTimetable.type}</dd>
                <dt>施行日</dt><dd>${displayTimetable.startDate || '未設定'}</dd>
                <dt>運転区間 (運用)</dt><dd>${integratedRun.route}</dd> 
                <dt>運行区間 (運転時刻による)</dt><dd>${displayTimetable.origin}〜${displayTimetable.destination}</dd>
                <dt>計画状況</dt><dd>${integratedRun.status}</dd>
            `;
            document.getElementById('block-details').innerHTML = detailHtml;
            
            // 時刻表情報: 統合された全区間の時刻表を線区ごとに分けて表示
            // V23: タイトル変更、線区ヘッダー削除
            let tableHtml = `
                <h3>運転時刻</h3>
                <table>
                    <colgroup>
                        <col class="station-col">
                        <col class="time-col">
                        <col class="time-col">
                        <col class="track-col">
                    </colgroup>
                    <tr><th>駅名</th><th>着時刻</th><th>発（通）時刻</th><th>番線</th></tr>
            `;
            
            const trim = (s) => s ? s.trim() : '';
            let previousSegmentEndStation = null;
            
            displayTimetable.segments.forEach((segment, segmentIndex) => {
                
                // V23: 青色の線区区間ヘッダー行を完全に削除
                /* const line = trim(segment.line) || '';
                tableHtml += `<tr><td colspan="4" class="segment-header">
                    ${line} (${trim(segment.origin)}〜${trim(segment.destination)})
                </td></tr>`;
                */
                
                segment.stops.forEach((stop, stopIndex) => {
                    
                    // V22: 接続駅の重複表示を抑制
                    const currentStation = trim(stop.station);
                    const isFirstStopOfSegment = stopIndex === 0;

                    if (segmentIndex > 0 && isFirstStopOfSegment && currentStation === previousSegmentEndStation) {
                        // 2つ目以降のセグメントの最初の駅が、前のセグメントの終着駅と同じ場合、この行はスキップ
                        return;
                    } 
                    
                    // V21/V22: 時刻データ（特殊記号もそのまま表示）
                    const arrival = trim(stop.arrival) || '';
                    const departure = trim(stop.departure) || '';
                    
                    // その他データ（null/'不明'は空白に）
                    const stationName = currentStation || '';
                    const trackN = trim(stop.trackN);
                    const normalizedTrackN = (trackN === '不明' || trackN === 'null' || trackN === 'NULL') ? '' : trackN;
                    
                    tableHtml += `<tr>
                        <td>${stationName}</td>
                        <td>${arrival}</td>
                        <td>${departure}</td>
                        <td>${normalizedTrackN}</td>
                    </tr>`;
                    
                    // 終着駅情報を更新
                    if (stopIndex === segment.stops.length - 1) {
                         previousSegmentEndStation = currentStation;
                    }
                });
            });

            tableHtml += '</table>';
            document.getElementById('timetable-details').innerHTML = tableHtml;

            modalOverlay.style.display = 'block';
        }
        
        /**
         * 運用ラベルクリック時の運用全体表示 
         */
        function openOperationDetails(operationNumber, division) {
            const originalOperation = globalData.find(op => op.operation_number === operationNumber && op.division === division);

            if (!originalOperation) {
                alert('ERROR: 運用データが見つかりません。');
                return;
            }
            
            // モーダルを運用全体モードに設定
            modalTitle.textContent = `運用詳細情報: ${originalOperation.operation_number} (${originalOperation.division})`;
            modalContent.style.display = 'none'; 
            allRunsContainer.style.display = 'block'; 
            operationRunsTitle.textContent = '車両運用計画'; // 見出しを修正

            const allRunsList = document.getElementById('all-runs-list');
            
            // 運用詳細情報の表示形式を修正
            let htmlContent = `
                <div class="op-details-line">
                    <dt>ID:</dt><dd>${originalOperation.id}</dd>
                    <dt>種別:</dt><dd>${originalOperation.type}</dd>
                    <dt>曜日:</dt><dd>${originalOperation.weekday || '設定なし'}</dd>
                    <dt>日付:</dt><dd>${originalOperation.date || '設定なし'}</dd>
                    <dt>所属区:</dt><dd>${originalOperation.division}</dd>
                    <dt>形式:</dt><dd>${originalOperation.vehicles}</dd>
                    <dt>後継運用:</dt><dd>${originalOperation.successor || 'なし'}</dd>
                </div>
                
                <h4 style="color: #000080; border-top: 1px solid #808080; padding-top: 10px;">運用列車</h4>
                <table class="modal-op-runs-table">
                <tr>
                    <th>列車番号</th>
                    <th>区間 (route)</th>
                    <th>備考</th>
                </tr>
            `;

            originalOperation.train_runs.forEach(run => {
                // 運行中の列車ブロックがあればクリック可能にする
                const runInTimeline = currentScheduleData.find(op => op.operation_number === operationNumber && op.division === division)
                    ?.runs.find(r => r.trainNumber === run.train_number);
                
                const trAttributes = runInTimeline 
                    ? `onclick="openDetailModal('${run.train_number}', '${operationNumber}', '${division}')" style="cursor: pointer;"`
                    : '';

                htmlContent += `
                    <tr ${trAttributes}>
                        <td>${run.train_number}</td>
                        <td>${run.route}</td>
                        <td></td> </tr>
                `;
            });
            
            htmlContent += `</table>`;
            allRunsList.innerHTML = htmlContent;

            modalOverlay.style.display = 'block';
        }


        // ----------------------------------------------------------------
        // 3. UIレンダリング 
        // ----------------------------------------------------------------
        
        function updateDivisionSelector(divisions) {
            divisionSelector.innerHTML = '<option value="">全ての区所</option>';
            const sortedDivisions = Array.from(divisions).sort();
            sortedDivisions.forEach(div => {
                const option = document.createElement('option');
                option.value = div;
                option.textContent = div;
                divisionSelector.appendChild(option);
            });
            divisionSelector.value = divisionSelector.dataset.currentFilter || "";
        }

        function renderTimeHeader() {
            scheduleTable.innerHTML = '';
            const headerRow = document.createElement('div');
            headerRow.classList.add('header-row');

            const emptyLabel = document.createElement('div');
            emptyLabel.classList.add('operation-label');
            emptyLabel.style.borderBottom = 'none';
            emptyLabel.style.gridRow = '1';
            emptyLabel.textContent = ''; 
            scheduleTable.appendChild(emptyLabel);

            for (let h = 0; h <= 23; h++) {
                const hourCell = document.createElement('div');
                hourCell.classList.add('time-header-cell');
                hourCell.textContent = String(h);
                hourCell.style.gridRow = '1';
                scheduleTable.appendChild(hourCell);
            }
            
            const hourCell24 = document.createElement('div');
            hourCell24.classList.add('time-header-cell');
            hourCell24.textContent = '24';
            hourCell24.style.gridRow = '1';
            scheduleTable.appendChild(hourCell24);
        }
        
        function renderSchedule(data) {
            currentScheduleData = data; 
            renderTimeHeader();

            let rowIndex = 2; 

            data.forEach(operation => {
                const opLabelContent = `<span class="number">${operation.operation_number}</span><span class="division">(${operation.division})</span>`;

                const operationLabel = document.createElement('div');
                operationLabel.classList.add('operation-label');
                operationLabel.innerHTML = opLabelContent;
                operationLabel.title = `形式: ${operation.vehicles}\nクリックで運用詳細を表示`;
                operationLabel.style.gridRow = String(rowIndex);
                operationLabel.id = `op-row-${operation.operation_number}-${operation.division}`; 
                operationLabel.dataset.opNumber = operation.operation_number;
                operationLabel.dataset.division = operation.division;
                
                // 運行データがない運用はクラスを追加して色を薄くする
                if (!operation.hasRuns) {
                    operationLabel.classList.add('no-runs');
                }
                
                // 運用ラベルにクリックイベントを追加
                operationLabel.addEventListener('click', () => {
                    openOperationDetails(operation.operation_number, operation.division);
                });
                
                scheduleTable.appendChild(operationLabel);

                const runContainer = document.createElement('div');
                runContainer.classList.add('train-run-container');
                runContainer.style.gridRow = String(rowIndex);
                scheduleTable.appendChild(runContainer);

                operation.runs.forEach(item => {
                    const startMin = item.startTime;
                    const endMin = item.endTime;

                    const block = document.createElement('div');
                    block.classList.add('train-block', `status-${item.status}`);
                    
                    // 列車ブロックの表示形式: 列車番号 (1全角スペース) 始発駅〜終着駅
                    const routeText = `${item.startStation}〜${item.endStation}`;
                    block.textContent = `${item.trainNumber}　${routeText}`;
                    
                    block.dataset.trainNumber = item.trainNumber;
                    block.dataset.operationNumber = item.operationNumber;
                    block.dataset.division = item.division; 
                    block.dataset.runIndex = item.runIndex; 
                    block.dataset.currentStatus = item.status;
                    
                    const totalMinutes = MIN_IN_DAY;
                    const left = (startMin / totalMinutes) * 100; 
                    const width = ((endMin - startMin) / totalMinutes) * 100; 

                    block.style.left = `${left}%`;
                    block.style.width = `${width}%`;
                    
                    block.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // 列車詳細表示は統合された運行データを使用
                        openDetailModal(item.trainNumber, item.operationNumber, item.division); 
                    });
                    runContainer.appendChild(block);
                });

                rowIndex++;
            });
        }

        // ----------------------------------------------------------------
        // 4. 機能（検索、全画面、ズーム）
        // ----------------------------------------------------------------

        function searchTrain() {
            const searchTerm = searchInput.value.trim();
            if (!searchTerm) return;
            
            clearSearch();
            
            const targetBlock = document.querySelector(`.train-block[data-train-number="${searchTerm}"]`);
            if (targetBlock) {
                targetBlock.classList.add('highlight');

                const targetOpNumber = targetBlock.dataset.operationNumber;
                const opRow = document.querySelector(`[data-op-number="${targetOpNumber}"]`); 
                if (opRow) {
                     opRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                const blockLeft = targetBlock.offsetLeft;
                const containerWidth = scheduleContainer.clientWidth;
                const blockWidth = targetBlock.offsetWidth;
                
                scheduleContainer.scrollLeft = blockLeft - (containerWidth / 2) + (blockWidth / 2);
            } else {
                alert(`列車番号 "${searchTerm}" の運行は現在表示されていません。`);
            }
        }
        
        function clearSearch() {
            document.querySelectorAll('.train-block.highlight').forEach(b => b.classList.remove('highlight'));
            searchInput.value = '';
        }

        function updateSchedule() {
            const dateValue = dateSelector.value;
            selectedDate = dateValue ? new Date(dateValue) : null; 

            const divisionFilter = divisionSelector.value;
            
            // タイムライン描画用の統合データを作成
            const scheduleData = createScheduleData(globalData, selectedDate, divisionFilter);
            renderSchedule(scheduleData);
            clearSearch();
        }

        function updateOutputDatetime() {
            const now = new Date();
            const y = now.getFullYear();
            const m = String(now.getMonth() + 1).padStart(2, '0');
            const d = String(now.getDate()).padStart(2, '0');
            const h = String(now.getHours()).padStart(2, '0');
            const mi = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            outputDatetimeSpan.textContent = `出力日時: ${y}/${m}/${d} ${h}:${mi}:${s}`;
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`全画面表示を有効にできませんでした: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        function updateZoom() {
            const zoomLevel = zoomRange.value;
            scheduleTable.style.setProperty('--timeline-min-width', `${zoomLevel}px`);
            zoomValueSpan.textContent = `${zoomLevel}px`;
        }


        // ----------------------------------------------------------------
        // 5. 初期化とイベントリスナー
        // ----------------------------------------------------------------

        async function initialize() {
            updateOutputDatetime();
            today = new Date();
            
            try {
                [globalTimetables, globalData] = await Promise.all([
                    fetchJson(TIMETABLES_URL),
                    fetchJson(DATA_URL)
                ]);

                // 時刻表データを事前にマップ化
                timetablesMap = preprocessTimetables(globalTimetables);

                // 日付セレクタを空にして全運用表示をデフォルトとする
                dateSelector.value = ''; 
                
                updateSchedule();
                updateZoom(); 
                
            } catch (error) {
                const errorMsg = `致命的なエラー: データ読み込み中にエラーが発生しました。パスを確認してください。: ${error.message}`;
                alert(errorMsg);
            }
        }

        document.getElementById('close-modal').addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });
        modalOverlay.addEventListener('click', (e) => {
            if (e.target.id === 'modal-overlay') {
                modalOverlay.style.display = 'none';
            }
        });
        
        // グローバルスコープに関数を公開
        window.openDetailModal = openDetailModal;
        window.openOperationDetails = openOperationDetails; 

        dateSelector.addEventListener('change', updateSchedule);
        divisionSelector.addEventListener('change', () => {
            divisionSelector.dataset.currentFilter = divisionSelector.value;
            updateSchedule();
        });

        searchButton.addEventListener('click', searchTrain);
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') searchTrain();
        });
        clearSearchButton.addEventListener('click', clearSearch);
        
        fullscreenButton.addEventListener('click', toggleFullscreen);
        zoomRange.addEventListener('input', updateZoom);

        initialize();

    </script>
</body>
</html>
