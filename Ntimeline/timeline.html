<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®Ÿæ–½åˆ—è»Šé‹è»¢è¨ˆç”»è¡¨(V1.6)</title>
    <style>
        /* ----------------------------------------------------------------
        * 0. æ¨™æº–ãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ (ã‚²ãƒ¼ãƒ ãƒ•ã‚©ãƒ³ãƒˆä¸­æ­¢)
        * ---------------------------------------------------------------- */
        
        /* ----------------------------------------------------------------
        * 1. ãƒ™ãƒ¼ã‚¹CSS 
        * ---------------------------------------------------------------- */
        body {
            /* æ¨™æº–ãƒ•ã‚©ãƒ³ãƒˆï¼ˆã‚´ã‚·ãƒƒã‚¯ä½“ï¼‰ã‚’é©ç”¨ */
            font-family: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯', 'MS Gothic', 'Osaka-Mono', monospace, 'Misaki Gothic','ãƒ¡ã‚¤ãƒªã‚ª', Meiryo, 'æ¸¸ã‚´ã‚·ãƒƒã‚¯', 'Yu Gothic';
            background-color: #191970; /* å¤‰æ›´: æ·¡ã„é’ */
            color: #c0c0c0;
            margin: 0;
            padding: 15px;
            font-size: 14px; /* æ¨™æº–ãƒ•ã‚©ãƒ³ãƒˆã«åˆã‚ã›ã¦ã‚µã‚¤ã‚ºã‚’èª¿æ•´ */
            min-width: 320px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            line-height: 1.4; 
        }

        h1 {
            color: #ffff00;
            text-align: center;
            border-bottom: 2px solid #c0c0c0;
            padding-bottom: 5px;
            margin-bottom: 15px;
            flex-shrink: 0;
            position: relative;
            font-size: 1.5em; 
        }
        
        /* æ™‚åˆ»è¡¨ç¤ºã‚³ãƒ³ãƒ†ãƒŠ */
        #time-display {
            position: absolute;
            bottom: 5px;
            right: 0;
            text-align: right;
        }

        #current-time {
            font-size: 1.0em; /* ç¾åœ¨æ™‚åˆ» */
            color: #ffffff;
            font-weight: bold;
            display: block;
        }
        
        #output-datetime {
            font-size: 0.7em; /* å‡ºåŠ›æ—¥æ™‚ã‚’å°ã•ã */
            color: #888888;
            display: block;
        }

        /* åˆ¶å¾¡ãƒ‘ãƒãƒ« */
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 15px;
            margin-bottom: 15px;
            background-color: #0d0d0d; 
            padding: 10px;
            border: 1px solid #c0c0c0;
            justify-content: flex-start;
            flex-shrink: 0;
        }

        #controls label, #controls input, #controls select, #controls button {
            color: #c0c0c0;
            background-color: #0d0d0d;
            border: 1px solid #c0c0c0;
            padding: 3px 5px;
            font-family: inherit; /* æ¨™æº–ãƒ•ã‚©ãƒ³ãƒˆç¶™æ‰¿ */
            font-size: inherit; 
        }
        
        #controls button:hover {
            background-color: #444444; 
            cursor: pointer;
        }
        
        #controls select option {
            background-color: #191970; /* bodyã¨åŒã˜æ·¡ã„é’ */
        }

        #fullscreen-button {
            background-color: #555555;
            border: 1px solid #c0c0c0;
            color: #ffffff;
            font-weight: bold;
            padding: 3px 10px;
            font-size: inherit; 
        }
        #fullscreen-button:hover {
             background-color: #777777;
        }
        
        /* ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            padding-left: 20px;
            border-left: 1px solid #444444;
        }
        #zoom-range {
            width: 150px;
        }
        #zoom-value {
            font-size: 0.8em;
        }

        /* ----------------------------------------------------------------
        * 2. ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã‚¨ãƒªã‚¢ 
        * ---------------------------------------------------------------- */
        #schedule-container {
            overflow: auto; 
            flex-grow: 1;
            border: 2px solid #c0c0c0;
            background-color: #0d0d0d; 
        }

        #schedule-table {
            grid-template-columns: var(--op-label-width, 100px) repeat(1440, 1fr); 
            min-width: var(--timeline-min-width, 4000px); 
            border-collapse: collapse;
            display: grid; 
        }

        /* æ™‚åˆ»ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .time-header-cell {
            grid-column: span 60; 
            text-align: left;
            padding: 5px 0 5px 5px;
            border-right: 1px solid #333333;
            box-sizing: border-box;
            font-size: 0.9em;
            background-color: #222222; 
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* é‹ç”¨ãƒ©ãƒ™ãƒ« - 2è¡Œè¡¨ç¤º */
        .operation-label {
            grid-column: 1 / 2;
            padding: 5px;
            border-bottom: 1px dotted #333333;
            background-color: #333333; 
            font-weight: bold;
            position: sticky;
            left: 0;
            z-index: 5;
            white-space: nowrap;
            font-size: 1.0em;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            line-height: 1.2;
            cursor: pointer; 
        }
        
        /* V3.0: æ—¥è·¨ãè¡Œã®ãƒ©ãƒ™ãƒ« */
        .operation-label.continuation {
            background-color: #444400; 
            color: #eeee00;
            font-size: 0.85em;
        }

        .operation-label:hover {
            background-color: #555555; 
        }
        
        /* é‹è¡Œãƒ‡ãƒ¼ã‚¿ãŒãªã„é‹ç”¨ã¯è‰²ã‚’è–„ãã™ã‚‹ */
        .operation-label.no-runs {
            color: #666666;
            background-color: #2a2a2a; 
        }

        .operation-label span.division {
            font-size: 0.8em;
            color: #888888;
            font-weight: normal;
        }
        
        .operation-label span.start-date {
            display: none; 
        }

        .train-run-container {
            grid-column: 2 / 1442; 
            position: relative;
            height: 40px;
            border-bottom: 1px dotted #333333;
        }

        /* é‹è¡Œãƒ–ãƒ­ãƒƒã‚¯ã®CSS */
        .train-block {
            position: absolute;
            height: 30px;
            top: 5px;
            border: 1px solid #c0c0c0;
            cursor: pointer;
            font-size: 0.8em; /* ã‚µã‚¤ã‚ºèª¿æ•´ */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 0 5px;
            white-space: nowrap;
            transition: all 0.1s;
            box-sizing: border-box;
        }

        /* V3.0: æ—¥è·¨ãã§åˆ†å‰²ã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ */
        .train-block.continuation-start {
            border-right: 3px solid #ff00ff; /* è·¨ãé–‹å§‹ã¯å³ã‚’å¼·èª¿ */
        }
        .train-block.continuation-end {
            border-left: 3px solid #ff00ff; /* è·¨ãçµ‚äº†ã¯å·¦ã‚’å¼·èª¿ */
        }


        .highlight {
            border: 3px solid #ffff00 !important;
            box-shadow: 0 0 10px #ffff00;
            background-color: #4b0082 !important;
        }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã”ã¨ã®è‰²ã®å®šç¾© */
        .status-è¨ˆç”»ä¸­ { background-color: #0000ff; color: #ffffff; } 
        .status-å®Ÿæ–½æ¸ˆã¿ { background-color: #008000; color: #ffffff; }
        .status-å®Ÿæ–½ä¸­ { background-color: #ff0000; color: #ffffff; } 
        .status-å–ã‚Šä¸‹ã’ { background-color: #808080; color: #000000; } 

        /* ----------------------------------------------------------------
        * 3. è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ« 
        * ---------------------------------------------------------------- */
        #modal-overlay {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 50;
            overflow-y: auto;
        }
        
        #detail-modal {
            background-color: #c0c0c0;
            color: #000000;
            border: 3px outset #ffffff; 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 900px;
            box-shadow: 8px 8px 0 #000000;
            font-family: inherit;
            font-size: 1em; /* æ¨™æº–ãƒ•ã‚©ãƒ³ãƒˆç¶™æ‰¿ */
        }
        
        #close-modal {
            background-color: red;
            color: white;
            border: none;
            cursor: pointer;
            padding: 3px 8px;
            font-weight: bold;
            position: absolute;
            right: 5px;
            top: 5px;
            font-size: inherit; 
        }

        .modal-content {
            padding: 15px;
            line-height: 1.5;
            display: flex;
            flex-direction: row; 
            gap: 20px;
        }
        
        .modal-info, .modal-timetable {
            flex: 1; 
            min-width: 300px;
        }

        .modal-timetable {
            overflow-y: auto;
            max-height: 400px; 
            border: 1px solid #808080;
        }
        
        /* é‹ç”¨å…¨ä½“è¡¨ç¤ºã®ãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .modal-op-runs-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-family: inherit;
        }
        .modal-op-runs-table th, .modal-op-runs-table td {
            border: 1px solid #808080;
            padding: 5px;
            text-align: left;
            font-size: 0.9em;
            background-color: #c0c0c0;
            color: #000000;
        }
        .modal-op-runs-table th {
            background-color: #000080; 
            color: #ffffff;
        }
        
        .modal-op-runs-table tr:hover td {
             background-color: #e0e0e0;
        }

        .modal-header {
            background-color: #000080; 
            color: #ffffff;
            padding: 5px;
            font-weight: bold;
            position: relative;
        }

        .modal-info dt {
            font-weight: bold;
            color: #000080; 
            margin-top: 5px;
        }
        
        .modal-timetable th, .modal-timetable td {
            border: 1px solid #808080;
            padding: 3px;
            text-align: left;
            background-color: #c0c0c0;
            color: #000000;
        }
        
        /* æ™‚åˆ»åˆ—å¹…å›ºå®šã¨é§…å/ç•ªç·šå¹…èª¿æ•´ */
        .modal-timetable table {
            table-layout: fixed;
            width: 100%; 
        }
        .modal-timetable table col.station-col {
            width: 30%; /* é§…å */
        }
        .modal-timetable table col.time-col {
            width: 27.5%; /* ç€æ™‚åˆ»/ç™ºæ™‚åˆ» */
        }
        .modal-timetable table col.track-col {
             width: 18%; /* ç•ªç·šï¼ˆåŠè§’ã‚¹ãƒšãƒ¼ã‚¹1ã¤åˆ†åºƒãç¶­æŒï¼‰ */
        }
        .modal-timetable table th:nth-child(2),
        .modal-timetable table td:nth-child(2),
        .modal-timetable table th:nth-child(3),
        .modal-timetable table td:nth-child(3) {
            text-align: center; /* æ™‚åˆ»ã‚’ä¸­å¤®å¯„ã› */
        }

        /* é‹ç”¨è©³ç´°æƒ…å ± */
        #all-runs-container dt {
             font-weight: bold;
             color: #000080; 
             margin-right: 5px; 
             display: inline;
        }
        #all-runs-container dd {
             margin-left: 0;
             margin-right: 15px;
             display: inline-block;
        }
        .op-details-line {
            line-height: 1.8;
            border-bottom: 1px solid #808080;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .op-details-line:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }


        /* ç¸¦ç”»é¢å¯¾å¿œ */
        @media (max-width: 800px) {
            .modal-content { flex-direction: column; }
            .modal-timetable { min-width: unset; max-height: 300px; }
            #detail-modal { width: 95%; top: 20px; transform: translate(-50%, 0); position: absolute; }
            #modal-overlay { overflow-y: auto; }
        }

    </style>
</head>
<body>

    <h1>å®Ÿæ–½åˆ—è»Šé‹è»¢è¨ˆç”»è¡¨<div id="time-display">
            <span id="current-time"></span>
            <span id="output-datetime"></span>
        </div>
    </h1> 

    <div id="controls">
        <label for="date-selector">è¡¨ç¤ºæ—¥ä»˜:</label>
        <input type="date" id="date-selector">
        
        <label for="division-selector">åŒºæ‰€çµã‚Šè¾¼ã¿:</label>
        <select id="division-selector">
            <option value="">å…¨ã¦ã®åŒºæ‰€</option>
            </select>
        
        <label for="search-train-number">åˆ—è»Šç•ªå·æ¤œç´¢:</label>
        <input type="text" id="search-train-number" placeholder="ä¾‹: 8764">
        <button id="search-button">æ¤œ ç´¢</button>
        <button id="clear-search">è§£é™¤</button>
        
        <button id="fullscreen-button">å…¨ç”»é¢è¡¨ç¤º</button>

        <div id="zoom-controls">
            <label>æ¨ªè»¸ã‚ºãƒ¼ãƒ :</label>
            <input type="range" id="zoom-range" min="1000" max="10000" step="500" value="4000">
            <span id="zoom-value">4000px</span>
        </div>
    </div>

    <div id="schedule-container">
        <div id="schedule-table">
            </div>
    </div>

    <div id="status-menu" style="display: none;"></div>
    
    <div id="modal-overlay">
        <div id="detail-modal">
            <div class="modal-header">
                <span id="modal-title">åˆ—è»Šé‹è¡Œè©³ç´°æƒ…å ±</span>
                <button id="close-modal">X</button>
            </div>
            <div id="modal-content" class="modal-content">
                <div class="modal-info">
                    <dl id="block-details">
                        </dl>
                </div>
                <div class="modal-timetable">
                    <div id="timetable-details">
                        </div>
                </div>
            </div>
            <div id="all-runs-container" style="padding: 15px; display: none;">
                <h3 id="operation-runs-title" style="color: #000080;"></h3>
                <div id="all-runs-list"></div>
            </div>
        </div>
    </div>


    <script>
        // ----------------------------------------------------------------
        // 1. å®šæ•°ã¨DOMè¦ç´ 
        // ----------------------------------------------------------------
        const TIMETABLES_URL = '../T-time/timetables.json'; 
        const DATA_URL = '../unnyou/data.json'; 
        const MIN_IN_DAY = 1440; // 24æ™‚é–“ = 1440åˆ†
        
        const scheduleTable = document.getElementById('schedule-table');
        const dateSelector = document.getElementById('date-selector');
        const divisionSelector = document.getElementById('division-selector');
        const searchInput = document.getElementById('search-train-number');
        const searchButton = document.getElementById('search-button');
        const clearSearchButton = document.getElementById('clear-search');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const allRunsContainer = document.getElementById('all-runs-container');
        const operationRunsTitle = document.getElementById('operation-runs-title');
        const scheduleContainer = document.getElementById('schedule-container');
        const outputDatetimeSpan = document.getElementById('output-datetime');
        const currentTimeSpan = document.getElementById('current-time'); 
        const fullscreenButton = document.getElementById('fullscreen-button');
        const zoomRange = document.getElementById('zoom-range'); 
        const zoomValueSpan = document.getElementById('zoom-value'); 

        let globalTimetables = [];
        let globalData = []; // å…ƒã®é‹ç”¨JSONã‚’ä¿æŒ
        let currentScheduleData = []; // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æç”»ç”¨ã®çµ±åˆ/ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
        let selectedDate = null;
        let today = new Date(); 
        
        // æ™‚åˆ»è¡¨ãƒ‡ãƒ¼ã‚¿ã‚’åˆ—è»Šç•ªå·ã¨æ–½è¡Œæ—¥ã§ãƒãƒƒãƒ—åŒ–ã—ã€ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’é«˜é€ŸåŒ–
        let timetablesMap = new Map();

        // V3.1: è¡¨ç¤ºæœŸé™ã‚’2026/03/13ã¾ã§ã¨ã™ã‚‹
        const ALWAYS_VISIBLE_DATES = [
            '2025/03/15',
            '2026/03/13' 
        ];
        
        // V3.0: æ™‚åˆ»ãƒ‡ãƒ¼ã‚¿ã¨è¦‹ãªã•ã‚Œã‚‹ç‰¹æ®Šè¨˜å· (æ™‚é–“è¨ˆç®—ã§ã¯nullã€è¡¨ç¤ºã§ã¯ãã®ã¾ã¾)
        const TIME_MARKERS = ['||', '=', 'â€¦', '...']; 
        
        /**
         * V3.0: nullå€¤ã‚’ç©ºç™½ã«å¤‰æ›ã™ã‚‹ãŒã€TIME_MARKERSã¯ãã®ã¾ã¾è¿”ã™ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
         */
        function cleanValue(value) {
            if (value === null || value === undefined) return '';
            const strValue = String(value).trim();
            
            // ç‰¹æ®Šè¨˜å·ã¯ãã®ã¾ã¾è¿”ã™
            if (TIME_MARKERS.includes(strValue)) return strValue; 

            // æ–‡å­—åˆ—ã¨ã—ã¦ã®"null"ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ç©ºç™½ã«å¤‰æ›
            if (strValue.toLowerCase() === 'null') return '';
            return strValue;
        }


        // ----------------------------------------------------------------
        // 2. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã¨ãƒ‡ãƒ¼ã‚¿å‡¦ç†
        // ----------------------------------------------------------------

        function timeToMinutes(timeStr) {
            const cleanStr = cleanValue(timeStr);
            // V3.0: TIME_MARKERSã¯æ™‚é–“è¨ˆç®—ã§ã¯é™¤å¤–
            if (!cleanStr || TIME_MARKERS.includes(cleanStr)) return null;
            
            const parts = cleanStr.split(':');
            if (parts.length < 2) return null;
            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);
            return hours * 60 + minutes;
        }
        
        function formatMinutesToTime(minutes) {
             if (minutes === null) return ''; 
             
             // V3.0: 24æ™‚é–“ä»¥ä¸Šã®è¡¨ç¤ºã«å¯¾å¿œ
             const totalHours = Math.floor(minutes / 60);
             const m = minutes % 60;
             return `${String(totalHours).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        }

        function formatDate(date) {
            if (!date) return null;
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}/${m}/${d}`;
        }
        
        function parseJsonDate(dateStr) {
            if (!dateStr) return null;
            const parts = cleanValue(dateStr).split('/');
            if (parts.length !== 3) return null;
            // YYYY/MM/DD å½¢å¼ã§ãƒ‘ãƒ¼ã‚¹
            return new Date(parts[0], parts[1] - 1, parts[2]);
        }
        
        /**
         * V3.1: æ–½è¡Œæ—¥ã¨è¡¨ç¤ºæ—¥ä»˜ã‚’æ¯”è¼ƒã—ã¦ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ±ºå®šã™ã‚‹
         * @param {string} startDateStr - JSONå†…ã®æ–½è¡Œæ—¥ ('YYYY/MM/DD' å½¢å¼)
         * @param {Date | null} displayDate - 'è¡¨ç¤ºæ—¥ä»˜' ã‚»ãƒ¬ã‚¯ã‚¿ã§é¸æŠã•ã‚ŒãŸæ—¥ä»˜
         * @returns {string} æ±ºå®šã•ã‚ŒãŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ('è¨ˆç”»ä¸­', 'å®Ÿæ–½ä¸­', 'å®Ÿæ–½æ¸ˆã¿')
         */
        function getAutoStatus(startDateStr, displayDate) {
            // æ–½è¡Œæ—¥ãŒæœªè¨­å®šã¾ãŸã¯è¡¨ç¤ºæ—¥ä»˜ãŒæœªé¸æŠã®å ´åˆã¯ã€Œè¨ˆç”»ä¸­ã€ã®ã¾ã¾
            if (!startDateStr || !displayDate) return "è¨ˆç”»ä¸­";
            
            const startDate = parseJsonDate(startDateStr);
            if (!startDate) return "è¨ˆç”»ä¸­";

            // æ—¥ä»˜ã®ã¿ã‚’æ¯”è¼ƒã™ã‚‹ãŸã‚ã€æ™‚åˆ»ã‚’ã‚¯ãƒªã‚¢ã—ã€ãƒŸãƒªç§’ã§æ¯”è¼ƒ
            const displayDayStart = new Date(displayDate.getFullYear(), displayDate.getMonth(), displayDate.getDate()).getTime();
            const startDayStart = startDate.getTime();
            
            // æ¯”è¼ƒã®åŸºæº–æ—¥
            const todayDayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();

            // 1. æ–½è¡Œæ—¥ãŒç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹è¡¨ç¤ºæ—¥ä»˜ã‚ˆã‚Šã‚‚æœªæ¥ã®å ´åˆ
            if (startDayStart > displayDayStart) {
                return "è¨ˆç”»ä¸­";
            } 
            
            // 2. æ–½è¡Œæ—¥ãŒç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹è¡¨ç¤ºæ—¥ä»˜ã‚ˆã‚Šã‚‚éå»ã®å ´åˆ
            if (startDayStart < displayDayStart) {
                return "å®Ÿæ–½æ¸ˆã¿";
            } 
            
            // 3. æ–½è¡Œæ—¥ãŒç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹è¡¨ç¤ºæ—¥ä»˜ã¨ä¸€è‡´ã™ã‚‹å ´åˆ (startDayStart === displayDayStart)
            if (startDayStart === displayDayStart) {
                // ã•ã‚‰ã«ã€ãã®æ—¥ãŒä»Šæ—¥ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®æ—¥ä»˜ã¨æ¯”è¼ƒã—ã¦ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                
                // å®Ÿè¡Œç’°å¢ƒã®æ—¥ä»˜ãŒæ–½è¡Œæ—¥ã‚ˆã‚Šã‚‚æœªæ¥ã§ã‚ã‚Œã°ã€è¡¨ç¤ºæ—¥ä»˜ã¯éå»ã®ã‚‚ã®ã¨ã¿ãªã—ã€Œå®Ÿæ–½æ¸ˆã¿ã€
                if (todayDayStart > startDayStart) {
                     return "å®Ÿæ–½æ¸ˆã¿";
                }
                
                // å®Ÿè¡Œç’°å¢ƒã®æ—¥ä»˜ãŒæ–½è¡Œæ—¥ã¨ä¸€è‡´ã™ã‚‹å ´åˆã¯ã€Œå®Ÿæ–½ä¸­ã€ç›¸å½“ã¨ã™ã‚‹
                if (todayDayStart === startDayStart) {
                    return "å®Ÿæ–½ä¸­";
                }
                
                // å®Ÿè¡Œç’°å¢ƒã®æ—¥ä»˜ãŒæ–½è¡Œæ—¥ã‚ˆã‚Šã‚‚æœªæ¥ã®å ´åˆã¯ã€Œè¨ˆç”»ä¸­ã€ (â€»ã“ã‚Œã¯è«–ç†çš„ã«ç™ºç”Ÿã—ãªã„ã¯ãšã ãŒä¿é™º)
                return "è¨ˆç”»ä¸­"; 
            }
            
            // ãã‚Œä»¥å¤–ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã€Œè¨ˆç”»ä¸­ã€
            return "è¨ˆç”»ä¸­";
        }

        async function fetchJson(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP Error: ${response.status} (${url})`);
            const text = await response.text();
            
            // V3.0: æ–‡å­—åˆ—ã¨ã—ã¦ã®"null"ã®ã¿ã‚’å‡¦ç† (ç‰¹æ®Šè¨˜å·ã¯é€šã™)
            const cleanText = text.replace(/"null"/g, '""');
            return JSON.parse(cleanText);
        }
        
        /**
         * timetables.json ã‚’ åˆ—è»Šç•ªå·ã¨æ–½è¡Œæ—¥ã§ãƒãƒƒãƒ—åŒ–ã™ã‚‹
         */
        function preprocessTimetables(timetables) {
            const map = new Map();
            timetables.forEach(t => {
                const dateKey = cleanValue(t.startDate) || 'NULL';
                const key = `${t.trainNumber}_${dateKey}`;
                
                if (!map.has(key)) {
                    map.set(key, []);
                }
                map.get(key).push(t);
            });
            return map;
        }
        
        /**
         * åŒã˜åˆ—è»Šç•ªå·ãƒ»æ–½è¡Œæ—¥ã®æ™‚åˆ»è¡¨ã‚¨ãƒ³ãƒˆãƒªã‚’é€£ç¶šæ€§ã«åŸºã¥ã„ã¦å®Œå…¨ã«çµåˆã™ã‚‹ 
         */
        function getIntegratedTimetable(trainNumber, startDate, allTimetables) {
            
            const trim = (s) => cleanValue(s);
            const matchingTimetables = allTimetables; 

            if (matchingTimetables.length === 0) return null;
            
            // 1. å§‹ç‚¹ã‚’è¦‹ã¤ã‘ã‚‹
            let currentRun = null;
            let earliestTime = 3000; 
            
            matchingTimetables.forEach(t => {
                // æœ€åˆã®é§…ã®ç€/ç™ºæ™‚åˆ»
                const firstStopDep = t.stops.find(s => timeToMinutes(s.departure) !== null);
                const firstStopArr = t.stops.find(s => timeToMinutes(s.arrival) !== null);
                
                let time = 3000;
                if (firstStopDep) time = timeToMinutes(firstStopDep.departure);
                else if (firstStopArr) time = timeToMinutes(firstStopArr.arrival);
                
                if (time !== 3000 && time < earliestTime) {
                    earliestTime = time;
                    currentRun = t;
                }
            });

            if (!currentRun) return null; 

            const usedTimetables = new Set();
            let combinedRuns = [currentRun];
            usedTimetables.add(currentRun);
            
            const maxSegments = matchingTimetables.length;

            // 2. å‰æ–¹å‘ (çµ‚ç‚¹æ–¹å‘) ã¸ã®é€£ç¶šã™ã‚‹æ™‚åˆ»è¡¨ã‚’æ¢ã—ã¦çµåˆ
            let attempts = 0;
            while (combinedRuns.length < maxSegments && attempts < maxSegments * 2) {
                const lastRun = combinedRuns[combinedRuns.length - 1];
                const nextOrigin = trim(lastRun.destination);
                let nextRun = null;
                
                for (const t of matchingTimetables) {
                    if (!usedTimetables.has(t) && trim(t.origin) === nextOrigin) {
                        nextRun = t;
                        break;
                    }
                }

                if (nextRun) {
                    usedTimetables.add(nextRun);
                    combinedRuns.push(nextRun);
                } else {
                    break; 
                }
                attempts++;
            }
            
            // 3. å¾Œã‚æ–¹å‘ (å§‹ç‚¹æ–¹å‘) ã¸ã®é€£ç¶šã™ã‚‹æ™‚åˆ»è¡¨ã‚’æ¢ã—ã¦çµåˆ
            attempts = 0;
            while (combinedRuns.length < maxSegments && attempts < maxSegments * 2) {
                const firstRun = combinedRuns[0];
                const previousDestination = trim(firstRun.origin);
                let previousRun = null;
                
                for (const t of matchingTimetables) {
                    if (!usedTimetables.has(t) && trim(t.destination) === previousDestination) {
                        previousRun = t;
                        break;
                    }
                }
                
                if (previousRun) {
                    usedTimetables.add(previousRun);
                    combinedRuns.unshift(previousRun); // é…åˆ—ã®å…ˆé ­ã«è¿½åŠ 
                } else {
                    break; 
                }
                attempts++;
            }
            
            // 4. æœªä½¿ç”¨ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã®å¼·åˆ¶çš„ãªè¿½åŠ 
            if (combinedRuns.length !== matchingTimetables.length) {
                const unUsed = matchingTimetables.filter(t => !usedTimetables.has(t));
                if (unUsed.length > 0) {
                    const allSegments = [...combinedRuns, ...unUsed].sort((a, b) => {
                        const getFirstTime = (segment) => {
                            // ä¿®æ­£: å¤‰æ•°åã‚’'s'ã§ã¯ãªã'stop'ã«ã™ã‚‹
                            const stopDep = segment.stops.find(stop => timeToMinutes(stop.departure) !== null);
                            if (stopDep) return timeToMinutes(stop.departure);
                            const stopArr = segment.stops.find(stop => timeToMinutes(stop.arrival) !== null);
                            if (stopArr) return timeToMinutes(stopArr.arrival);
                            return 3000; 
                        };
                        return getFirstTime(a) - getFirstTime(b);
                    });
                    combinedRuns = allSegments;
                }
            }


            if (combinedRuns.length === 0) return null;

            const finalFirstRun = combinedRuns[0];
            const finalLastRun = combinedRuns[combinedRuns.length - 1];
            
            // é‹è¡Œæ™‚é–“è¨ˆç®— (ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¡¨ç¤ºç”¨)
            let startTime = null;
            // ä¿®æ­£: 's' is not defined ã‚¨ãƒ©ãƒ¼å›é¿ã®ãŸã‚å¤‰æ•°åã‚’'startStop'ã«å¤‰æ›´
            const startStop = finalFirstRun.stops.find(s => timeToMinutes(s.departure) !== null); 
            if (startStop) startTime = timeToMinutes(startStop.departure);
            
            let endTime = null;
            const endStop = [...finalLastRun.stops].reverse().find(s => timeToMinutes(s.arrival) !== null);
            if (endStop) endTime = timeToMinutes(endStop.arrival);
            
            if (startTime === null || endTime === null) {
                 // é‹è¡Œæ™‚é–“ãŒå–å¾—ã§ããªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯ã‚’å¼·åŒ–
                 
                 let minTime = 3000;
                 let maxTime = 0;
                 
                 combinedRuns.forEach(segment => {
                      segment.stops.forEach(stop => {
                          const arr = timeToMinutes(stop.arrival);
                          const dep = timeToMinutes(stop.departure);
                          if (arr !== null) minTime = Math.min(minTime, arr);
                          if (dep !== null) minTime = Math.min(minTime, dep);
                          
                          if (arr !== null) maxTime = Math.max(maxTime, arr);
                          if (dep !== null) maxTime = Math.max(maxTime, dep);
                      });
                 });
                 
                 // ä¾ç„¶ã¨ã—ã¦æ™‚åˆ»ãŒå–å¾—ã§ããªã„å ´åˆã¯nullã‚’è¿”ã™
                 if (minTime === 3000 || maxTime === 0) return null;
                 
                 startTime = minTime;
                 endTime = maxTime;
            }

            return {
                trainNumber: trainNumber,
                type: trim(finalFirstRun.type),
                startDate: startDate, 
                origin: trim(finalFirstRun.origin), 
                destination: trim(finalLastRun.destination), 
                startTime: startTime,
                endTime: endTime,
                status: null,
                segments: combinedRuns, 
            };
        }
        
        /**
         * V3.0: é‹è¡ŒãŒæ—¥ã‚’è·¨ãå ´åˆã€1440åˆ†å˜ä½ã§è¤‡æ•°ã®æç”»ãƒ–ãƒ­ãƒƒã‚¯ã«åˆ†å‰²ã™ã‚‹
         * @param {Object} runData - çµ±åˆã•ã‚ŒãŸé‹è¡Œãƒ‡ãƒ¼ã‚¿
         * @returns {Array<Object>} åˆ†å‰²ã•ã‚ŒãŸæç”»ãƒ–ãƒ­ãƒƒã‚¯ã®é…åˆ—
         */
        function splitRunForDisplay(runData) {
            const blocks = [];
            let currentStart = runData.startTime;
            const totalEnd = runData.endTime;
            const dayOffset = Math.floor(currentStart / MIN_IN_DAY); // æ—¢ã«ä½•æ—¥ç›®ã‹ (é€šå¸¸ã¯0)
            
            // é‹è¡ŒãŒ24:00 (1440) ã‚’è·¨ããŸã³ã«åˆ†å‰²
            for (let d = dayOffset; currentStart < totalEnd; d++) {
                const nextDayBoundary = (d + 1) * MIN_IN_DAY;
                let blockEnd = Math.min(totalEnd, nextDayBoundary);
                
                const isContinuationStart = currentStart < nextDayBoundary && blockEnd === nextDayBoundary && totalEnd > nextDayBoundary;
                const isContinuationEnd = currentStart < nextDayBoundary && currentStart === d * MIN_IN_DAY && totalEnd > nextDayBoundary;

                blocks.push({
                    ...runData,
                    displayStart: currentStart,
                    displayEnd: blockEnd,
                    dayIndex: d - dayOffset, // 0:å½“æ—¥, 1:ç¿Œæ—¥, ...
                    isStartBlock: d === dayOffset, // æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‹
                    isEndBlock: blockEnd === totalEnd, // æœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ã‹
                    isContinuationStart: isContinuationStart, // æ—¥è·¨ãã§çµ‚ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‹
                    isContinuationEnd: isContinuationEnd // æ—¥è·¨ãã§å§‹ã¾ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‹
                });
                
                currentStart = nextDayBoundary;
            }
            return blocks;
        }


        /**
         * æ—¥ä»˜ã¨åŒºæ‰€ã«ã‚ˆã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã„ã€é‹ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
         * V3.1: åœè»Šé§…é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ ã—ã€ã‚¨ãƒ©ãƒ¼å›é¿ã®ãŸã‚ã®å®‰å…¨ãƒã‚§ãƒƒã‚¯ã‚’å¼·åŒ–
         */
        function createScheduleData(data, currentDate, divisionFilter) {
            const scheduleData = new Map();
            const divisions = new Set();
            
            data.forEach(op => divisions.add(op.division));
            updateDivisionSelector(divisions);
            
            const formattedCurrentDate = currentDate ? formatDate(currentDate) : null;
            const isDateSelected = !!dateSelector.value;
            
            // V3.1: è¡¨ç¤ºæœŸé™ã‚’ Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å–å¾— (2026/03/13)
            const maxDisplayDateStr = ALWAYS_VISIBLE_DATES[ALWAYS_VISIBLE_DATES.length - 1];
            const maxDisplayDate = parseJsonDate(maxDisplayDateStr);
            const maxDisplayDayStart = maxDisplayDate ? maxDisplayDate.getTime() : Infinity;


            data.forEach(operation => {
                if (divisionFilter && operation.division !== divisionFilter) return;
                
                const originalId = operation.id;

                const integratedRunsForOp = []; 
                
                const runsByTrainNumber = new Map();
                operation.train_runs.forEach(run => {
                    if (!runsByTrainNumber.has(run.train_number)) {
                        runsByTrainNumber.set(run.train_number, []);
                    }
                    runsByTrainNumber.get(run.train_number).push(run);
                });

                let foundMatchingRunForDate = false; 

                runsByTrainNumber.forEach((opRuns, trainNumber) => {
                    
                    // --- ğŸš… ã‚¨ãƒ©ãƒ¼å›é¿ã®ãŸã‚ã®å®‰å…¨ãƒã‚§ãƒƒã‚¯ã‚’å¼·åŒ– ğŸš… ---
                    if (opRuns.length === 0) return; 
                    const firstOpRun = opRuns[0];
                    if (!firstOpRun) return; 
                    // ------------------------------------

                    const opRoutes = opRuns.map(r => cleanValue(r.route)).filter(r => r); // é‹ç”¨å´ã®å…¨routeã‚’å–å¾—
                    if (opRoutes.length === 0) return; // routeè¨­å®šãŒãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—

                    const relevantTimetableEntries = Array.from(timetablesMap.entries())
                        .filter(([key, _]) => key.startsWith(`${trainNumber}_`));
                    
                    relevantTimetableEntries.forEach(([key, timeTableGroup]) => {
                        const startDate = key.split('_')[1] === 'NULL' ? null : key.split('_')[1];
                        
                        const integratedTimetable = getIntegratedTimetable(trainNumber, startDate, timeTableGroup);
                        
                        if (!integratedTimetable) return; 
                        
                        // --- ğŸš… æ–½è¡Œæ—¥ã«ã‚ˆã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° (V3.1) ğŸš… ---
                        const formattedStartDate = cleanValue(startDate);
                        
                        // æ–½è¡Œæ—¥ãŒæœ€å¤§è¡¨ç¤ºæ—¥ã‚ˆã‚Šæœªæ¥ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                        if (formattedStartDate) {
                            const currentStartDate = parseJsonDate(formattedStartDate);
                            if (currentStartDate && currentStartDate.getTime() > maxDisplayDayStart) {
                                return; // ã‚¹ã‚­ãƒƒãƒ—
                            }
                        }
                        
                        // --- ğŸš… ã‚ˆã‚Šå³å¯†ãªåœè»Šé§…é‡è¤‡ãƒã‚§ãƒƒã‚¯ (V3.1) ğŸš… ---
                        // 1. æ™‚åˆ»è¡¨å†…ã®å…¨é§…åã‚’å–å¾—
                        const ttAllStations = integratedTimetable.segments.flatMap(segment => 
                            segment.stops.map(s => cleanValue(s.station)).filter(s => s)
                        );
                        
                        // 2. é‹ç”¨å´ã®å…¨ã¦ã®routeæ–‡å­—åˆ—ã‚’çµåˆ
                        const combinedOpRoutes = opRoutes.join(' / '); 

                        // 3. å«ã¾ã‚Œã‚‹é§…ã®ã‚«ã‚¦ãƒ³ãƒˆ
                        let matchedStationCount = 0;
                        ttAllStations.forEach(ttStation => {
                            if (combinedOpRoutes.includes(ttStation)) {
                                matchedStationCount++;
                            }
                        });

                        // 4. é™¤å¤–åˆ¤å®š: 1é§…ã‚‚ä¸€è‡´ã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                        if (matchedStationCount === 0) {
                             // console.warn(`SKIP: ${trainNumber} (${startDate}) - æ™‚åˆ»è¡¨ (${ttAllStations.join(',')})ã®é§…ãŒã€é‹ç”¨ãƒ«ãƒ¼ãƒˆ (${combinedOpRoutes})ã¨1é§…ã‚‚ä¸€è‡´ã—ãªã„ãŸã‚é™¤å¤–ã€‚`);
                             return; // æ˜ã‚‰ã‹ã«åˆ¥è·¯ç·šã®ãƒ‡ãƒ¼ã‚¿ã¨åˆ¤æ–­ã—ã€ç ´æ£„
                        }
                        // ------------------------------------

                        let shouldDisplay = false;
                        if (!isDateSelected) { 
                            shouldDisplay = true; 
                        } else { 
                            const isNoDate = formattedStartDate === '';
                            const isSpecificDate = ALWAYS_VISIBLE_DATES.includes(formattedStartDate);
                            const isSelectedDate = (formattedStartDate === formattedCurrentDate);
                            
                            shouldDisplay = isNoDate || isSpecificDate || isSelectedDate;
                        }

                        if (!shouldDisplay) return;

                        // V3.1: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¿®æ­£
                        let status = cleanValue(firstOpRun.status);
                        if (isDateSelected && formattedStartDate) {
                             // æ—¥ä»˜ãŒé¸æŠã•ã‚Œã€æ–½è¡Œæ—¥ã‚‚è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿è‡ªå‹•åˆ¤å®š
                             status = getAutoStatus(formattedStartDate, currentDate);
                        } else if (!status) {
                             status = "è¨ˆç”»ä¸­";
                        }
                        
                        const runData = {
                            trainNumber: trainNumber,
                            type: integratedTimetable.type,
                            route: opRuns.map(r => cleanValue(r.route)).join(' â†’ '), 
                            startStation: integratedTimetable.origin, 
                            endStation: integratedTimetable.destination, 
                            startTime: integratedTimetable.startTime, 
                            endTime: integratedTimetable.endTime,     
                            status: status, 
                            operationId: originalId, 
                            operationNumber: operation.operation_number,
                            division: operation.division,
                            runIndex: firstOpRun.runIndex, 
                            startDate: formattedStartDate === '' ? null : formattedStartDate,
                            timetable: integratedTimetable
                        };

                        integratedRunsForOp.push(runData);
                        foundMatchingRunForDate = true; 
                    });
                });
                
                integratedRunsForOp.sort((a, b) => a.startTime - b.startTime);

                const runsByStartDate = new Map();
                integratedRunsForOp.forEach(run => {
                    const key = run.startDate || 'COMMON'; 
                    if (!runsByStartDate.has(key)) {
                        runsByStartDate.set(key, []);
                    }
                    runsByStartDate.get(key).push(run);
                });

                runsByStartDate.forEach((runs, startDateKey) => {
                    const labelStartDate = startDateKey === 'COMMON' ? null : startDateKey;
                    
                    const hasRuns = runs.length > 0;
                    
                    // V29/V3.0: æ—¥ä»˜ãŒé¸æŠã•ã‚Œã¦ã„ã¦ã€é‹è¡ŒãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆã—ãªã„
                    if (isDateSelected && !hasRuns) return; 
                    
                    const uniqueOpLabelKey = `${operation.division}_${operation.operation_number}_${labelStartDate || 'COMMON'}`;

                    if (!scheduleData.has(uniqueOpLabelKey)) {
                        scheduleData.set(uniqueOpLabelKey, {
                            id: originalId, 
                            operation_number: operation.operation_number,
                            division: operation.division,
                            vehicles: operation.vehicles,
                            startDate: labelStartDate, 
                            runs: [],
                            hasRuns: false,
                            displayBlocks: [] // V3.0: åˆ†å‰²å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ ¼ç´
                        });
                    }
                    
                    // é‹è¡Œãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²ã—ã€displayBlocksã«è¿½åŠ 
                    let totalBlocks = [];
                    runs.forEach(run => {
                        const blocks = splitRunForDisplay(run);
                        totalBlocks.push(...blocks);
                    });
                    
                    // dayIndexã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã€é‹ç”¨è¡Œã«ç´ã¥ã‘ã‚‹
                    const blocksByDay = new Map();
                    totalBlocks.forEach(block => {
                        const dayKey = block.dayIndex;
                        if (!blocksByDay.has(dayKey)) {
                             blocksByDay.set(dayKey, []);
                        }
                        blocksByDay.get(dayKey).push(block);
                    });
                    
                    const opData = scheduleData.get(uniqueOpLabelKey);
                    opData.runs.push(...runs);
                    opData.hasRuns = hasRuns;
                    opData.displayBlocks = blocksByDay; // dayIndexã”ã¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã®Mapã‚’æ ¼ç´
                });

                if (!foundMatchingRunForDate && !isDateSelected) { 
                     const uniqueOpLabelKey = `${operation.division}_${operation.operation_number}_COMMON`;
                     if (!scheduleData.has(uniqueOpLabelKey)) {
                         scheduleData.set(uniqueOpLabelKey, {
                             id: originalId, 
                             operation_number: operation.operation_number,
                             division: operation.division,
                             vehicles: operation.vehicles,
                             startDate: null,
                             runs: [],
                             hasRuns: false,
                             displayBlocks: new Map()
                         });
                     }
                }
            });

            // V3.0: æœ€çµ‚çš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚½ãƒ¼ãƒˆ
            return Array.from(scheduleData.values()).sort((a, b) => {
                
                if (!isDateSelected) {
                    // æ—¥ä»˜æœªé¸æŠæ™‚: IDé †ï¼ˆå…ƒã®JSONé †ï¼‰ã‚’æœ€å„ªå…ˆ
                    if (a.id !== b.id) return a.id - b.id;
                }
                
                // å…±é€šã®ã‚½ãƒ¼ãƒˆé †: åŒºæ‰€å > é‹ç”¨ç•ªå· > æ–½è¡Œæ—¥
                const divA = cleanValue(a.division);
                const divB = cleanValue(b.division);
                const opA = cleanValue(a.operation_number);
                const opB = cleanValue(b.operation_number);
                const dateA = a.startDate || '';
                const dateB = b.startDate || '';
                
                if (divA !== divB) return divA.localeCompare(divB);
                if (opA !== opB) return opA.localeCompare(opB);
                return dateA.localeCompare(dateB);
            });
        }


        /**
         * åˆ—è»Šãƒ–ãƒ­ãƒƒã‚¯ã‚¯ãƒªãƒƒã‚¯æ™‚ã®è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
         */
        function openDetailModal(trainNumber, operationNumber, division, startDate) {
            
            const operationBlock = currentScheduleData.find(op => 
                op.operation_number === operationNumber && 
                op.division === division && 
                (op.startDate === startDate || (op.startDate === null && startDate === 'null'))
            );
            
            const integratedRun = operationBlock?.runs.find(r => r.trainNumber === trainNumber);

            if (!integratedRun || !integratedRun.timetable) {
                alert('ERROR: è©³ç´°ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }
            
            const displayTimetable = integratedRun.timetable; 
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’åˆ—è»Šè©³ç´°ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š
            modalTitle.textContent = `åˆ—è»Šé‹è¡Œè©³ç´°æƒ…å ±: ${cleanValue(trainNumber)}`;
            modalContent.style.display = 'flex';
            allRunsContainer.style.display = 'none';

            const displayStartDate = integratedRun.startDate || 'æœªè¨­å®š';

            let detailHtml = `
                <dt>é‹ç”¨ç•ªå· (åŒºæ‰€)</dt><dd>${cleanValue(operationBlock.operation_number)} (${cleanValue(operationBlock.division)})</dd>
                <dt>å½¢å¼</dt><dd>${cleanValue(operationBlock.vehicles)}</dd>
                <dt>åˆ—è»Šç•ªå·</dt><dd>${cleanValue(trainNumber)}</dd>
                <dt>åˆ—è»Šç¨®åˆ¥</dt><dd>${cleanValue(displayTimetable.type)}</dd>
                <dt>æ–½è¡Œæ—¥</dt><dd>${displayStartDate}</dd>
                <dt>é‹è»¢åŒºé–“ (é‹ç”¨)</dt><dd>${cleanValue(integratedRun.route)}</dd> 
                <dt>é‹è¡ŒåŒºé–“ (é‹è»¢æ™‚åˆ»ã«ã‚ˆã‚‹)</dt><dd>${cleanValue(displayTimetable.origin)}ã€œ${cleanValue(displayTimetable.destination)}</dd>
                <dt>é‹è¡Œæ™‚é–“</dt><dd>${formatMinutesToTime(displayTimetable.startTime)} ã€œ ${formatMinutesToTime(displayTimetable.endTime)}</dd>
                <dt>è¨ˆç”»çŠ¶æ³</dt><dd>${cleanValue(integratedRun.status)}</dd>
            `;
            document.getElementById('block-details').innerHTML = detailHtml;
            
            // æ™‚åˆ»è¡¨æƒ…å ±
            let tableHtml = `
                <h3>é‹è»¢æ™‚åˆ»</h3>
                <table>
                    <colgroup>
                        <col class="station-col">
                        <col class="time-col">
                        <col class="time-col">
                        <col class="track-col">
                    </colgroup>
                    <tr><th>é§…å</th><th>ç€æ™‚åˆ»</th><th>ç™ºï¼ˆé€šï¼‰æ™‚åˆ»</th><th>ç•ªç·š</th></tr>
            `;
            
            let previousSegmentEndStation = null;
            
            displayTimetable.segments.forEach((segment, segmentIndex) => {
                
                segment.stops.forEach((stop, stopIndex) => {
                    
                    const currentStation = cleanValue(stop.station);
                    const isFirstStopOfSegment = stopIndex === 0;

                    if (segmentIndex > 0 && isFirstStopOfSegment && currentStation === previousSegmentEndStation) {
                        return; // æ¥ç¶šé§…ã®é‡è¤‡è¡¨ç¤ºã‚’ã‚¹ã‚­ãƒƒãƒ—
                    } 
                    
                    const arrival = cleanValue(stop.arrival);
                    const departure = cleanValue(stop.departure);
                    const trackN = cleanValue(stop.trackN);
                    
                    tableHtml += `<tr>
                        <td>${currentStation}</td>
                        <td>${arrival}</td>
                        <td>${departure}</td>
                        <td>${trackN}</td>
                    </tr>`;
                    
                    // çµ‚ç€é§…æƒ…å ±ã‚’æ›´æ–°
                    if (stopIndex === segment.stops.length - 1) {
                         previousSegmentEndStation = currentStation;
                    }
                });
            });

            tableHtml += '</table>';
            document.getElementById('timetable-details').innerHTML = tableHtml;

            modalOverlay.style.display = 'block';
        }
        
        /**
         * é‹ç”¨ãƒ©ãƒ™ãƒ«ã‚¯ãƒªãƒƒã‚¯æ™‚ã®é‹ç”¨å…¨ä½“è¡¨ç¤º 
         */
        function openOperationDetails(operationNumber, division) {
            const originalOperation = globalData.find(op => op.operation_number === operationNumber && op.division === division);

            if (!originalOperation) {
                alert('ERROR: é‹ç”¨ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é‹ç”¨å…¨ä½“ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š
            modalTitle.textContent = `é‹ç”¨è©³ç´°æƒ…å ±: ${cleanValue(originalOperation.operation_number)} (${cleanValue(originalOperation.division)})`;
            modalContent.style.display = 'none'; 
            allRunsContainer.style.display = 'block'; 
            operationRunsTitle.textContent = 'è»Šä¸¡é‹ç”¨è¨ˆç”»'; 

            const allRunsList = document.getElementById('all-runs-list');
            
            // é‹ç”¨è©³ç´°æƒ…å ±
            let htmlContent = `
                <div class="op-details-line">
                    <dt>ID:</dt><dd>${cleanValue(originalOperation.id)}</dd>
                    <dt>ç¨®åˆ¥:</dt><dd>${cleanValue(originalOperation.type)}</dd>
                    <dt>æ›œæ—¥:</dt><dd>${cleanValue(originalOperation.weekday) || 'è¨­å®šãªã—'}</dd>
                    <dt>æ—¥ä»˜:</dt><dd>${cleanValue(originalOperation.date) || 'è¨­å®šãªã—'}</dd>
                    <dt>æ‰€å±åŒº:</dt><dd>${cleanValue(originalOperation.division)}</dd>
                    <dt>å½¢å¼:</dt><dd>${cleanValue(originalOperation.vehicles)}</dd>
                    <dt>å¾Œç¶™é‹ç”¨:</dt><dd>${cleanValue(originalOperation.successor) || 'ãªã—'}</dd>
                </div>
                
                <h4 style="color: #000080; border-top: 1px solid #808080; padding-top: 10px;">é‹ç”¨åˆ—è»Š</h4>
                <table class="modal-op-runs-table">
                <tr>
                    <th>åˆ—è»Šç•ªå·</th>
                    <th>åŒºé–“ (route)</th>
                    <th>å‚™è€ƒ</th>
                </tr>
            `;

            originalOperation.train_runs.forEach(run => {
                const runsInTimeline = currentScheduleData.flatMap(op => op.runs).filter(r => 
                    r.trainNumber === run.train_number && 
                    r.operationNumber === operationNumber &&
                    r.division === division
                );
                
                let trAttributes = '';
                if (runsInTimeline.length > 0) {
                     const firstRun = runsInTimeline[0];
                     const startDateAttr = firstRun.startDate || 'null'; 
                     trAttributes = `onclick="openDetailModal('${cleanValue(run.train_number)}', '${cleanValue(operationNumber)}', '${cleanValue(division)}', '${startDateAttr}')" style="cursor: pointer;"`;
                }

                htmlContent += `
                    <tr ${trAttributes}>
                        <td>${cleanValue(run.train_number)}</td>
                        <td>${cleanValue(run.route)}</td>
                        <td></td> 
                    </tr>
                `;
            });
            
            htmlContent += `</table>`;
            allRunsList.innerHTML = htmlContent;

            modalOverlay.style.display = 'block';
        }


        // ----------------------------------------------------------------
        // 3. UIãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° 
        // ----------------------------------------------------------------
        
        function updateDivisionSelector(divisions) {
            divisionSelector.innerHTML = '<option value="">å…¨ã¦ã®åŒºæ‰€</option>';
            const sortedDivisions = Array.from(divisions).sort();
            sortedDivisions.forEach(div => {
                const option = document.createElement('option');
                option.value = div;
                option.textContent = div;
                divisionSelector.appendChild(option);
            });
            divisionSelector.value = divisionSelector.dataset.currentFilter || "";
        }

        function renderTimeHeader() {
            scheduleTable.innerHTML = '';
            const headerRow = document.createElement('div');
            headerRow.classList.add('header-row');

            const emptyLabel = document.createElement('div');
            emptyLabel.classList.add('operation-label');
            emptyLabel.style.borderBottom = 'none';
            emptyLabel.style.gridRow = '1';
            emptyLabel.textContent = ''; 
            scheduleTable.appendChild(emptyLabel);

            for (let h = 0; h <= 23; h++) {
                const hourCell = document.createElement('div');
                hourCell.classList.add('time-header-cell');
                hourCell.textContent = String(h);
                hourCell.style.gridRow = '1';
                scheduleTable.appendChild(hourCell);
            }
            
            const hourCell24 = document.createElement('div');
            hourCell24.classList.add('time-header-cell');
            hourCell24.textContent = '24';
            hourCell24.style.gridRow = '1';
            scheduleTable.appendChild(hourCell24);
        }
        
        function renderSchedule(data) {
            currentScheduleData = data; 
            renderTimeHeader();

            let rowIndex = 2; 

            data.forEach(operation => {
                
                const opNum = cleanValue(operation.operation_number);
                const opDiv = cleanValue(operation.division);
                const opDate = operation.startDate ? operation.startDate : '';
                
                // V3.0: æ—¥è·¨ããƒ–ãƒ­ãƒƒã‚¯ã®æœ€å¤§æ—¥æ•° (æœ€å¤§+2æ—¥ã¾ã§è¡¨ç¤ºã‚’è€ƒæ…®)
                const maxDayIndex = operation.displayBlocks.size > 0 ? Math.max(...operation.displayBlocks.keys()) : 0; 

                // é‹ç”¨ãƒ©ãƒ™ãƒ«ã¨ã‚³ãƒ³ãƒ†ãƒŠã‚’æ—¥è·¨ãåˆ†ï¼ˆ0æ—¥ç›®ã‹ã‚‰æœ€å¤§æ—¥æ•°ï¼‰ä½œæˆ
                for (let dayIndex = 0; dayIndex <= maxDayIndex; dayIndex++) {
                    
                    const isBaseRow = dayIndex === 0;
                    const daySuffix = isBaseRow ? '' : ` (+${dayIndex} day)`;
                    const rowOpNum = opNum + daySuffix;
                    const rowIdSuffix = isBaseRow ? 'common' : `day${dayIndex}`;
                    
                    if (dayIndex > 0 && !operation.displayBlocks.has(dayIndex)) {
                        continue; // é‹è¡ŒãŒãªã‘ã‚Œã°æ—¥è·¨ãè¡Œã¯ä½œã‚‰ãªã„
                    }
                    
                    // --------------------------------------------------------
                    // é‹ç”¨ãƒ©ãƒ™ãƒ«
                    // --------------------------------------------------------
                    const dateHtml = ''; 
                    const opLabelContent = `<span class="number">${rowOpNum}</span><span class="division">(${opDiv})</span>${dateHtml}`;

                    const operationLabel = document.createElement('div');
                    operationLabel.classList.add('operation-label');
                    if (!isBaseRow) {
                        operationLabel.classList.add('continuation');
                    }
                    operationLabel.innerHTML = opLabelContent;
                    operationLabel.title = `å½¢å¼: ${cleanValue(operation.vehicles)}\næ–½è¡Œæ—¥: ${opDate || 'å…±é€š'}${daySuffix}\nã‚¯ãƒªãƒƒã‚¯ã§é‹ç”¨è©³ç´°ã‚’è¡¨ç¤º`;
                    operationLabel.style.gridRow = String(rowIndex);
                    operationLabel.id = `op-row-${opNum}-${opDiv}-${opDate || 'common'}-${rowIdSuffix}`; 
                    operationLabel.dataset.opNumber = opNum;
                    operationLabel.dataset.division = opDiv;
                    operationLabel.dataset.startDate = opDate || 'null'; 
                    operationLabel.dataset.dayIndex = dayIndex; // V3.0: ä½•æ—¥ç›®ã®è¡Œã‹
                    
                    if (!operation.hasRuns) {
                        operationLabel.classList.add('no-runs');
                    }
                    
                    // é‹ç”¨ãƒ©ãƒ™ãƒ«ã«ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ  (é‹ç”¨å…¨ä½“ã®è©³ç´°è¡¨ç¤º)
                    // V3.0: ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‹•ä½œã¯å…ƒã®é‹ç”¨ï¼ˆ0æ—¥ç›®ï¼‰ã¨åŒã˜
                    operationLabel.addEventListener('click', () => {
                        openOperationDetails(opNum, opDiv);
                    });
                    
                    scheduleTable.appendChild(operationLabel);

                    // --------------------------------------------------------
                    // é‹è¡Œã‚³ãƒ³ãƒ†ãƒŠã¨ãƒ–ãƒ­ãƒƒã‚¯
                    // --------------------------------------------------------
                    const runContainer = document.createElement('div');
                    runContainer.classList.add('train-run-container');
                    runContainer.style.gridRow = String(rowIndex);
                    scheduleTable.appendChild(runContainer);
                    
                    const blocksToDisplay = operation.displayBlocks.get(dayIndex) || [];

                    blocksToDisplay.forEach(item => {
                        // V3.0: è¡¨ç¤ºã™ã‚‹é–‹å§‹ãƒ»çµ‚äº†æ™‚åˆ»ã¯0ã€œ1440ã«æ­£è¦åŒ–
                        const startMin = item.displayStart % MIN_IN_DAY;
                        const endMin = item.displayEnd % MIN_IN_DAY;
                        // 1440åˆ†ã´ã£ãŸã‚Šã§çµ‚ã‚ã‚‹å ´åˆã€endMinã¯0ã«ãªã‚‹ã®ã§1440ã«è£œæ­£
                        const normalizedEndMin = endMin === 0 && item.displayEnd !== 0 ? MIN_IN_DAY : endMin; 
                        
                        const block = document.createElement('div');
                        block.classList.add('train-block', `status-${cleanValue(item.status)}`);
                        
                        // V3.0: æ—¥è·¨ãç”¨ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                        if (item.isContinuationStart) {
                            block.classList.add('continuation-start');
                        }
                        if (item.isContinuationEnd) {
                            block.classList.add('continuation-end');
                        }
                        
                        const routeText = `${cleanValue(item.startStation)}ã€œ${cleanValue(item.endStation)}`;
                        const displayStartStr = formatMinutesToTime(item.displayStart);
                        const displayEndStr = formatMinutesToTime(item.displayEnd);
                        
                        // V3.0: ãƒ–ãƒ­ãƒƒã‚¯å†…éƒ¨ã®è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆã¯ã€å…ƒã®é‹è¡Œç•ªå·ã¨é‹è¡ŒåŒºé–“ã«å¤‰æ›´ãªã—
                        block.textContent = `${cleanValue(item.trainNumber)}ã€€${routeText}`;
                        
                        // ãƒã‚¦ã‚¹ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã«ã€24æ™‚é–“ä»¥ä¸Šã®æ™‚åˆ»ã‚’è¡¨ç¤º
                        block.title = `${cleanValue(item.trainNumber)} (${item.status})\n${routeText}\n${displayStartStr} ã€œ ${displayEndStr}`;

                        const itemOpNum = cleanValue(item.operationNumber);
                        const itemDiv = cleanValue(item.division);
                        const itemDate = item.startDate || 'null';

                        block.dataset.trainNumber = cleanValue(item.trainNumber);
                        block.dataset.operationNumber = itemOpNum;
                        block.dataset.division = itemDiv; 
                        block.dataset.startDate = itemDate; 
                        block.dataset.runIndex = cleanValue(item.runIndex); 
                        block.dataset.currentStatus = cleanValue(item.status);
                        
                        const totalMinutes = MIN_IN_DAY;
                        const left = (startMin / totalMinutes) * 100; 
                        const width = ((normalizedEndMin - startMin) / totalMinutes) * 100; 
                        
                        // V3.0: 24:00 (1440) å§‹ã¾ã‚Šã®ãƒ–ãƒ­ãƒƒã‚¯ã¯Left=0, Width=çµ‚äº†æ™‚åˆ»ã§è¨ˆç®—
                        if (startMin === 0 && normalizedEndMin === MIN_IN_DAY) {
                             block.style.left = `0%`;
                             block.style.width = `100%`;
                        } else if (startMin === 0 && item.displayEnd > MIN_IN_DAY) {
                             block.style.left = `0%`;
                             block.style.width = `${(endMin / totalMinutes) * 100}%`;
                        } else {
                             block.style.left = `${left}%`;
                             block.style.width = `${width}%`;
                        }

                        block.addEventListener('click', (e) => {
                            e.stopPropagation();
                            openDetailModal(item.trainNumber, itemOpNum, itemDiv, itemDate); 
                        });
                        runContainer.appendChild(block);
                    });

                    rowIndex++;
                }
            });
        }

        // ----------------------------------------------------------------
        // 4. æ©Ÿèƒ½ï¼ˆæ¤œç´¢ã€å…¨ç”»é¢ã€ã‚ºãƒ¼ãƒ ã€æ™‚åˆ»ï¼‰
        // ----------------------------------------------------------------

        function searchTrain() {
            const searchTerm = cleanValue(searchInput.value).trim();
            if (!searchTerm) return;
            
            clearSearch();
            
            let found = false;
            let firstBlock = null;

            document.querySelectorAll('.train-block').forEach(block => {
                const trainNumber = block.dataset.trainNumber;
                if (trainNumber.includes(searchTerm)) { 
                    block.classList.add('highlight');
                    found = true;
                    if (!firstBlock) {
                        firstBlock = block;
                    }
                }
            });

            if (firstBlock) {
                // V3.0: ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½ã®ä¿®å¾©ï¼ˆæ—¥è·¨ãè¡Œã«ã‚‚å¯¾å¿œï¼‰
                const targetOpNumber = firstBlock.dataset.operationNumber;
                const targetDivision = firstBlock.dataset.division;
                const targetStartDate = firstBlock.dataset.startDate || 'common'; 
                
                // V3.0: æ—¥è·¨ãè¡Œã‚‚å«ã‚€IDã§æ¤œç´¢
                let opRow = firstBlock.closest('.train-run-container').previousElementSibling; // éš£ã®é‹ç”¨ãƒ©ãƒ™ãƒ«ã‚’å–å¾—

                if (opRow && opRow.classList.contains('operation-label')) {
                     // ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                     opRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    // å¿µã®ãŸã‚ã€å…ƒé‹ç”¨è¡Œã®IDã§æ¤œç´¢ã‚’è©¦ã¿ã‚‹
                    opRow = document.querySelector(`[data-op-number="${targetOpNumber}"][data-division="${targetDivision}"][data-start-date="${targetStartDate}"][data-day-index="0"]`);
                    if(opRow) opRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }


                // æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                const blockLeft = firstBlock.offsetLeft;
                const containerWidth = scheduleContainer.clientWidth;
                const blockWidth = firstBlock.offsetWidth;
                
                // ãƒ–ãƒ­ãƒƒã‚¯ãŒç”»é¢ä¸­å¤®ã«æ¥ã‚‹ã‚ˆã†ã«è¨ˆç®—
                scheduleContainer.scrollLeft = blockLeft - (containerWidth / 2) + (blockWidth / 2);
            } else {
                alert(`åˆ—è»Šç•ªå· "${searchTerm}" ã®é‹è¡Œã¯ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚`);
            }
        }
        
        function clearSearch() {
            document.querySelectorAll('.train-block.highlight').forEach(b => b.classList.remove('highlight'));
            searchInput.value = '';
        }

        function updateSchedule() {
            const dateValue = dateSelector.value;
            // V1.6: selectedDateã«ã¯Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒ
            selectedDate = dateValue ? new Date(dateValue) : null; 

            const divisionFilter = divisionSelector.value;
            
            // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æç”»ç”¨ã®çµ±åˆãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
            // V1.6: createScheduleDataã«selectedDateã‚’æ¸¡ã™
            const scheduleData = createScheduleData(globalData, selectedDate, divisionFilter);
            renderSchedule(scheduleData);
            clearSearch();
        }

        // V3.0: ç¾åœ¨æ™‚åˆ»è¡¨ç¤ºã®æ›´æ–°
        function updateTimeDisplay() {
            const now = new Date();
            const h = String(now.getHours()).padStart(2, '0');
            const mi = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            currentTimeSpan.textContent = `ç¾åœ¨æ™‚åˆ»: ${h}:${mi}:${s}`;
            
            if (outputDatetimeSpan.textContent.length < 5) {
                const y = now.getFullYear();
                const m = String(now.getMonth() + 1).padStart(2, '0');
                const d = String(now.getDate()).padStart(2, '0');
                const oh = String(now.getHours()).padStart(2, '0');
                const omi = String(now.getMinutes()).padStart(2, '0');
                const os = String(now.getSeconds()).padStart(2, '0');
                outputDatetimeSpan.textContent = `å‡ºåŠ›æ—¥æ™‚: ${y}/${m}/${d} ${oh}:${omi}:${os}`;
            }
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`å…¨ç”»é¢è¡¨ç¤ºã‚’æœ‰åŠ¹ã«ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        function updateZoom() {
            const zoomLevel = zoomRange.value;
            scheduleTable.style.setProperty('--timeline-min-width', `${zoomLevel}px`);
            zoomValueSpan.textContent = `${zoomLevel}px`;
        }


        // ----------------------------------------------------------------
        // 5. åˆæœŸåŒ–ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        // ----------------------------------------------------------------

        async function initialize() {
            updateTimeDisplay();
            setInterval(updateTimeDisplay, 1000); 

            today = new Date();
            
            try {
                [globalTimetables, globalData] = await Promise.all([
                    fetchJson(TIMETABLES_URL),
                    fetchJson(DATA_URL)
                ]);

                // V3.0: å…ƒã®ãƒ‡ãƒ¼ã‚¿ã«IDã‚’ä»˜ä¸ã™ã‚‹ï¼ˆIDã‚½ãƒ¼ãƒˆæ™‚ã«å¿…è¦ï¼‰
                globalData.forEach((op, index) => {
                    op.id = op.id || index + 1; 
                });

                // æ™‚åˆ»è¡¨ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰ã«ãƒãƒƒãƒ—åŒ–
                timetablesMap = preprocessTimetables(globalTimetables);

                // æ—¥ä»˜ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ç©ºã«ã—ã¦å…¨é‹ç”¨è¡¨ç¤ºã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹
                dateSelector.value = ''; 
                
                updateSchedule();
                updateZoom(); 
                
            } catch (error) {
                const errorMsg = `è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼: ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ‘ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚: ${error.message}`;
                alert(errorMsg);
            }
        }

        document.getElementById('close-modal').addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });
        modalOverlay.addEventListener('click', (e) => {
            if (e.target.id === 'modal-overlay') {
                modalOverlay.style.display = 'none';
            }
        });
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢æ•°ã‚’å…¬é–‹
        window.openDetailModal = openDetailModal;
        window.openOperationDetails = openOperationDetails; 

        dateSelector.addEventListener('change', updateSchedule);
        divisionSelector.addEventListener('change', () => {
            divisionSelector.dataset.currentFilter = divisionSelector.value;
            updateSchedule();
        });

        searchButton.addEventListener('click', searchTrain);
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') searchTrain();
        });
        clearSearchButton.addEventListener('click', clearSearch);
        
        fullscreenButton.addEventListener('click', toggleFullscreen);
        zoomRange.addEventListener('input', updateZoom);

        initialize();

    </script>
</body>
</html>
